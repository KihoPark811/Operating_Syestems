# 컴퓨터 구조와 어셈블리 언어(2장)
![image](https://github.com/user-attachments/assets/15cd8e2b-8ec6-4da6-b072-0b88999829c4)
- 위 그림은 하드웨어 회로 상에서 주소가 할당된 예를 보여준다.
- CPU는 각 장치를 담당하는 제어기(Controller)에 적절한 명령을 전달하고, 그 결과를 읽어온다.
- 각 입출력 제어기에는 CPU로부터 명령을 받고 결과를 반환하기 위한 주소가 할당되어 있는데, 이것은 하드웨어 설계 단계에서 설계자가 적절히 선택하여 설계에 반영한다.
### CPU(Central Processing Unit)
- 중앙 처리 장치로서, 연산, 제어, 입출력 관리, 명령 해석, 메모리 접근 등을 수행하는 컴퓨터 시스템의 핵심 부품
### 데이터 흐름
1. 메모리에서 명령어나 데이터를 읽어온다.
2. CPU가 그것을 해석하고 처리한다.
3. 필요 시, 입출력 장치 제어기(I/O Controller)에 명령을 전달한다.
4. 입출력 장치와의 데이터 송수신을 담당하는 건 제어기(Controller)이다.
### 시스템 버스(System Bus)
- 버스는 단순 선이 아닌, 데이터 전송을 위한 신호들의 묶음이다.
  ### 세 가지 구성 요소
  - 주소 버스(Address Bus): 어디(메모리나 장치)에 접근할 것인지 주솔르 지정한다.
  - 데이터 버스(Data Bus): 실제 데이터를 전달한다.
  - 제어 버스(Control Bus): 읽기/쓰기 신호, 인터럽트, 클럭 등 제어 신호를 전달한다. 
## 주소 디코딩
- 주소 버스(Address Bus)의 값을 받아, 특정한 메모리 블록 또는 입출력 장치를 선택하는 회로이다.
- 즉, CPU가 특정 주소에 접근했을 때 그 주소가 어떤 장치에 해당하는지를 판단하고, 해당 장치에 연결된 회로만 활성화(선택)된다는 의미이다.
- 각 구성모듈들에 대해 일정한 주소 영역이 할당되어 있어서 CPU로부터 주소가 나오면 구성모듈들 중에서 오직 하나만이 선택되어 활성화된다.
- 주소 디코더(Address Decoder)들은 할당된 주소에 맞게 조합 논리회로(현재 입력에 따라 출력이 항상 똑같이 결정되는 논리회로)로 구성되는데, 할당된 주소영역이 적용될 때에만 출력을 활성화하여 해당 모듈이 활성화 되도록 한다.

![image](https://github.com/user-attachments/assets/dbeb738a-3119-4171-bb35-58b3098c0dc2)

### 주소 맵(Address Map or Memory Map)
- 각 모듈별로 할당된 주소의 집합

![image](https://github.com/user-attachments/assets/a8ede196-864c-4cdd-91f8-167cff692d05)

- A(19-0): 20개의 구리선으로 구성된다.
- 예를 들어, 주소 맵이 RAM은 0x00000번지부터 0x3ffff번까지 256K 바이트 크기를 가지고, ROM은 0x40000 번지부터 0x4ffff번지까지 64K 바이트의 크기를 가지며, I/O 장치는 0x80000번지부터 0x80003번지까지 4바이트의 크기를 가질 경우를 가정하면 각 대상별 주소 범위는 위의 첫째 그림과 같고 이에 따른 주소 디코더는 위의 그림과 같이 구성 할 수 있다.

![image](https://github.com/user-attachments/assets/cab51f7b-b506-4ca1-bf3a-613f4eb9f37e)

## 입출력 장치 제어
![image](https://github.com/user-attachments/assets/ae051509-52bf-49c6-8fb2-8c565141a0f0)
- 명령전달: 장치의 종류에 상관없이 보낼 수 있다.
- 작업완료 확인:
  - Polling(장치의 상태 메시지를 계속 확인한다.)
  - Interrupt
- 데이터 입출력 

### 입출력 장치 제어기를 구성하는 요소
- **제어 레지스터**: CPU로부터 명령을 받아들인다.
- **상태 레지스터**: 장치의 상태를 나타낸다.
- **데이터 레지스터**: 입출력 데이터를 처리한다.
### 입출력 장치 제어는 어떤 원리로 작동하는가?
1. CPU가 특정 입출력 장치 제어기의 제어 레지스터에 특정 명령을 의미하는 값을 기록한다.
2. 해당 제어기는 그 값을 확인하고, 지정된 작업을 수행한 후에 결과를 상태 레지스터에 기록해 둔다.
3. CPU는 이것을 읽어내어서 작업 결과를 확인할 수 있게 되며, 입출력 데이터 자체는 데이터 레지스터 부분을 읽거나 기록하는 것으로 처리한다.

### 작업 완료 확인 방법
1. **폴링(Polling)**
  - CPU는 명령을 전달한 후에 반복적으로 상태 레지스터를 읽어 보고 완료 여부를 확인한다.
  - 실행이 완료될 때까지 계속 검사를 해야 하므로 인터럽트 방식에 비해 시간 낭비를 초래한다.**(폴링 방식의 단점!)**
2. **인터럽트(Interrupt)**
  - CPU는 명령을 전달한 후에 작업이 완료될 때까지 다른 프로세스를 실행한다.
  - 명령을 받은 제어기는 지시받은 작업이 완료되는 시점에 CPU에 인터럽트 신호를 발생시킨다.
  - 이 신호에 따라 CPU는 해당 인터럽트 처리 루틴을 실행하게 되고, 여기서 작업 결과를 확인하는 절차를 실행한다.

## Direct Memory Access
![image](https://github.com/user-attachments/assets/3dab4505-7604-45b6-8fbb-35327d3da3b5)
- 기능이 있는 입출력 장치 제어기의 동작 과정
  1. CPU가 제어기로 명령을 전달해 놓는다.
  2. 제어기에서는 전달받은 명령에 따라 입출력 작업을 직접 메모리에 읽기나 쓰기 작업으로 처리한다.
  3. 작업이 완료된 시점에 CPU에게 인터럽트 신호를 발생시킨다.
  → CPU는 인터럽트 신호가 발생하면 그 처리 과정에서 입출력 작업 완료 후에 해야 할 작업을 진행하게 된다. 

- 디스크 입출력과 같이 한번에 대량의 데이터를 처리해야 하는 경우, 매 데이터 단위마다 CPU가 명령을 전달하고, 결과를 받는 과정을 거친다면 실행 속도가 많이 느려지게 된다.
- 인터럽트 신호는 장치마다 우선순위가 있는데, 장치 레벨이 높은 하드웨어에 먼저 우선순위가 부여되고, 장치레벨이 같다면 먼저 신호가 들어오거나 우선순위가 높은 인터럽트 신호가 먼저 처리된다.
- 여러 개의 인터럽트가 동시에 발생하면, 인터럽트 컨트롤러가 우선순위를 결정하여 CPU에 전달하고, CPU는 그 순서에 따라 인터럽트를 처리한다.
### DMA 제어기(DMAC: Direct Memory Access Controller)
- 이러한 반복적인 작업을 전담하는 장치로서, 입력 작업을 위해서는 직접 주변 장치의 제어기로부터 데이터를 받아서 메모리의 지정된 영역에 차례대로 기록하고, 출력 작업을 위해서는 그 반대의 작업을 실행한다.
- 즉, 메모리에는 CPU뿐만 아니라 DMAC도 읽거나 쓰기 작업을 실행한다.

## 디스크 제어기의 DMAC(디스크 제어기 명령전달 절차)
![image](https://github.com/user-attachments/assets/63d970bc-c8fa-4d57-af98-b1f290af8919)
- 디스크 제어기의 제어 레지스터는 4개로 구성되는데, 0x80000 번지는 읽기(1)와 쓰기(2)를 구별하는 값, 0x80001 번지는 디스크 블록 번호, 0x8002 번지는 메모리 주소, 0x80003 번지는 바이트 수를 기록한다고 가정한다.
- 인터럽트 신호가 들어오면 OS 내부에서 처리된다.
- 프로세스 P2가 int 명령어를 통하여 디스크의 200번 블록에서 1024 바이트를 읽어서 메모리의 0x5100 번지부터 채우라는 파일 읽기 요청을 한다면,
  OS에서는 디스크 제어기에 다음과 같은 방법으로 명령을 전달한다.
  1. **mov $200, 0x80001**: 디스크 블록번호 레지스터에 200을 기록한다.
  2. **mov $0x5100, 0x80002**: 메모리 주소 레지스터에 0x5100을 기록한다.
  3. **mov $1024, 0x80003**: 크기 레지스터에 1024를 기록한다.
  4. **mov $1, 0x80000**: 읽기를 표시하는 값을 기록한다.
  5. 그러면, 디스크 제어기는 DMAC를 활용하여 지정된 작업을 완료한 후에 CPU에 인터럽트 신호를 보내게 된다.

## 프로세서의 프로그래밍 모델(ARM, X86)
![image](https://github.com/user-attachments/assets/5b7be54f-04a8-4dbe-b098-6d280991956e)
- 각종 하드웨어 장치를 제어하는 기능을 구현하는데 있어서 부분저긍로 고급 언어로는 표현이 불가능한 내용들이 있고, 이러한 부분은 어셈블리 언어로 표현하여야 한다.
- 따라서, 하나의 OS를 완성하는데 있어서 대부분 고급 언어를 사용하여 작성하고, 부분적으로는 어셈블리 언어로 작성하며, 이들을 하나로 결합하여 커널 파일로 완성해야 한다.
- 이렇게 작성된 커널 파일은 부팅 과정에서 메모리에 적재되어 실행된다.

## 8086 Processor 내부 구조(CPU 내부 동작 과정 / 16bit)
![image](https://github.com/user-attachments/assets/938b4c34-7a9d-459b-9352-a141a6decf61)
- 8086은 펜티엄의 선조에 해당하는 것으로서 비교적 간단하고 일반적인 PC에서 간편하게 사용해볼 수 있는 프로세서이다.
### 핵심 구성 요소 및 역할
- IP(Instruction Pointer): 다음에 실행할 명령어 주소를 저장
- Control Unit: 명령어 해석 및 제어 신호 생성
- ALU: 실제 산술/논리 연산 수행
- FLAGS: 연산 결과 상태 저장
- 레지스터(AX, BX 등): 데이터 임시 저장
- Address, Data Bus: 메모리와의 주소/데이터 송수신
- SP(Stack Pointer): 현재 스택의 최상단 주소를 가리킨다.(함수 호출, 지역 변수 저장, 함수 복귀 시 사용된다.)
- LR(Link Register): 함수 호출(Branch with Link, BL) 시 돌아올 주소를 지정한다.(즉, 함수가 끝난 뒤 어디로 복귀해야 할 지를 기억하는 역할)
- PC(Program Counter): 현재 실행 중인 명령어의 주소를 저장한다.(명령어가 실행될 때마다 자동으로 다음 주소로 증가한다.)
### 8086 프로세서 내부에서 명령어가 수행되는 과정
1. Instruction Fetch(명령어 가져오기)
- IP는 현재 실행할 명령어의 메모리 주소를 가지고 있다.
- 이 주솔르 Address 버스를 통해 외부 메모리에 전달한다.
- 해당 주소의 명령어가 Data Bus를 통해 내부로 들어온다.
2. Control Unit 처리
- 명령어가 들어오면 Control Unit이 이를 해석한다.
- 어떤 연산을 해야 하는지, 어떤 레지스터를 사용하는지 등 명령의 종류에 따라 다음 단계를 지시한다.
3. Operand 처리
- Control Unit의 지시에 따라 레시스터 파일(AX, BX, CX, DX 등)에서 피연산자(Operand)를 가져온다.
- SI, DI, BP, SP 등은 주소 계산이나 스택 조작 등에 사용된다.
4. 연산 수행
- 피연산자는 ALU(Arithmetic Logic Unit)로 전달된다.
- ALU는 덧셈, 뺄셈, AND/OR 등의 산술/논리 연산을 수행한다.
- 결과는 다시 레지스터에 저장되거나, 외부 메모리로 전달될 수 있다.
5. 플래그 갱신
- ALU 연산 결과에 따라 FLAGS 레지스터가 갱신된다.
- 예: 결과가 0인지, 캐리 발생 여부, 부호 등 
6. Instruction Pointer 증가
- 명령어가 끝나면 IP가 명령어 길이만큼 증가한다.
- 다음 명령어를 실행할 준비를 한다.
### 프로세서(Processor)
- CPU 기능을 하나의 칩으로 제작한 것으로, 하나의 작은 칩으로 제작되기 때문에 마이크로프로세서(Micro-Processor)라고 부르기도 하고, 이 칩에 여러 가지 부가 기능들이 추가되기도 한다.(CPU = Processor = Micro-Processor)
- 고급 언어로 작성된 부분은 사용하는 프로세서에 상관없이 컴파일러에 의해 자동으로 적절한 기계어 코드로 번역되지만, 어셈블리 언어로 작성하는 부분은 특정 프로세서에 맞게 작성해야 한다.(특히, 어셈블리 언어는 표준이 없으므로, 어셈블러마다 약간씩 차이가 있을 수 있다.)
### 레지스터(Register)
![image](https://github.com/user-attachments/assets/24627a5c-af96-4e50-8aab-8187106b38f8)
- Program Status Register: 오버플로우, 캐리, 음수 등 발생 시, 해당 내용을 저장하는 레지스터
- 어셈블리 언어로 작성된 프로그램은 프로세서 내부의 레지스터들을 적절히 활용하면서 메모리의 내용들과 레지스터들 간에 데이터를 이동하거나 연산 작업을 하는 것으로 표현한다.
- 프로그램이 실행되는 과정을 제어하기 위해서는 연산 결과에 따른 상태 조건에 의해 실행 위치를 분기하여 이동하는 작업 및 함수를 호출하고 결과를 반환하는 작업 등을 한다.
## C 언어, 어셈블리 언어, 기계어
![image](https://github.com/user-attachments/assets/416029c5-6cfe-4b01-a721-d871012d7741)
![image](https://github.com/user-attachments/assets/212cd8da-bbce-496e-a318-889e757b1d14)
### 위의 그림 분석
- **mov sum, %ax**: sum 변수가 있는 주소의 메모리 내용을 읽어서 프로세서 내부의 AX 레지스터에 기록한다.
- **add index, %ax**: index 변수가 있는 주소의 메모리 내용을 읽어서 AX 레지스터에 더한다.
- **mov %ax, sum**: 현재의 AX 레지스터의 내용을 sum 변수의 메모리 부분에 기록한다.
→ 이렇게 3개의 명령어를 통해서 sum 변수의 메모리 내용에는 index 변수의 값이 더해져 있게 된다.

- 변환 과정
  - C언어로 작성된 프로그램 → 컴파일 → 어셈블리어 → 기계어 코드 생성
- **C 컴파일러**: C 언어 프로그램에 표현된 의도대로 실행되도록 적절한 어셈블리 언어로 자동으로 변역한다.
- **어셈블러**: 이 프로그램을 기계어 코드로 번역해 준다.
  
![image](https://github.com/user-attachments/assets/3d7108b4-af23-4eab-8868-6ec8a03a8477)
- rrr로 표현된 부분: 레지스터 번호를 표현하는 부분
- 000으로 표현된 부분: AX 레지스터 표현
- 001으로 표현된 부분: BX 레지스터 표현
- aa...aa로 표현된 부분: 메모리 상의 주소를 나타낸다.

## 어셈블리 언어의 기초
![image](https://github.com/user-attachments/assets/cd5bc3b0-1233-48ab-8ffb-9cb19313ceed)
- 여기서 설명하는 내용은 gcc 컴파일러 패키지에 포함되어 있는 GNU 어셈블러 기준으로 한다.
- 어셈블리 언어 프로그램은 기본적으로 한줄 단위로 필요한 내용을 표시한다.
- 매 줄은 명령어(Command), 지시어(Directive), 레이블(Label) 또는 설명문(Comment) 중의 하나이다.
  - **명령어(Command)**: 프로세서가 실행해야 할 명령어들을 표시하는데, 첫 글자를 빈칸으로 시작하거나 레이블 다음에 따라올 수 있다.
  - **지시어(Directive)**: 어셈블러에게 정보를 전달하는 목적으로 표현하는 것으로, '.'으로 시작한다.
  - **레이블(Label)**: 적절한 문자열 다음에 ':'이 따라오는데 변수의 주소를 표시하거나 분기 명령어가 나올 때 분기 주소를 표시하는데 사용한다.
  - **설명문(Commnet)**: '#'으로 시작하며, 한 줄의 중간 부분에 '#'이 나오면 이후 그 줄의 끝까지가 설명문이다. 

## 레지스터와 명령어 구성 
![image](https://github.com/user-attachments/assets/8436c44b-b269-4018-b6ce-8d11d815f5f1)
### 대부분의 명령어 형식
**명령어 오퍼란드1, 오퍼란드2**
- 오퍼란드(Operand)는 명령어의 실행 대상을 지정한다. 
- Ex. addl %eax, %ebx : 첫 번째 오퍼란드인 EAX 레지스터의 값을 두 번째 오퍼란드인 EBX 레지스터에 더해주라는 의미이다.

### 어드레싱 모드(Addressing Mode): Operand를 지정하는 표시 방식
- **직접 주소 방식(Direct Addressing Mode)**: 메모리 상의 주소를 직접 지정하는 모드로, 프로그램 상에 사용되고 있는 임의의 레이블을 지정하거나 메모리 주소를 직접 수치로 지정한다.
- **레지스터 모드(Register Mode)**: 특정 레지스터를 지정하는데 레지스터 이름 앞에 '%'를 붙여서 표시한다.<br>
어셈블러는 '%'문자로 시작하는 문자열은 레지스터로 인식하고, 그렇지 않은 문자열은 레이블로 인식한다.
- **간접 주소 모드(Indirect Addressing Mode)**: 지정된 레지스터에 저장된 값이 메모리 주소가 되며, 그 주소에서 읽어온 값이 명령어가 처리할 값이다. (레지스터 이름에 괄호를 붙여서 표현한다. → "레지스터 간접주소 모드"라고도 한다.)<br>
예를 들어, '(%eax)'는 EAX 레지스터에 저장된 값을 메모리 주소로 사용하여 그 메모리의 내용을 사용하라는 표시이다. 변형된 표시 형식으로서 '4(%eax)'는 EAX 레지스터의 값에 4를 더한 결과를 메모리 주소로 사용하라는 의미이다.
- **즉치 모드(Immediate Value Mode)**: 지정하는 수치 자체가 명령어에서 처리할 값이 된다. 다른 모드에서는 지정된 대상에 기록된 내용이 명령어가 처리할 값이다.
즉치 모드의 수치는 '$'문자를 수치 앞에 붙여서 표현한다.
어셈블러는 '$'문자로 시작하는 수치는 즉치로 인식하고, 그렇지 않은 수치는 메모리 상의 주소로 인식한다.

![image](https://github.com/user-attachments/assets/7e7d0178-d812-468c-8623-71f794556923)
- Label 앞에 %가 안 붙는 이유: label 자체가 주소를 가리켜서 그런가?(나중에)
- 어떤 언어든 컴파일 과정에서 어셈블리어로 표현된다.
- 각 명령어에 있어서 기본 명령은 16 bit로 처리하고, 'l'이 끝에 덧붙은 명령어는 'long'의 의미로서 32 bit로 처리한다.<br>
예를 들어, 'add'는 16비트 단위의 덧셈 연산을 표시하고, 'addl'은 32비트 단위의 덧셈 연산을 표시한다.
- 레지스터 이름에서도 기본적인 이름은 16비트 크기이고, 'e'가 앞에 덧붙은 레지스터는 extended의 의미로서 32비트 크기를 의미한다.
예를 들어, '%eax'는 32비트 크기의 EAX 레지스터이고, '%ax'는 16비트 크기의 AX 레지스터로서 EAX 레지스터의 하위 16비트 부분을 의미한다.

![image](https://github.com/user-attachments/assets/dbeef04b-ab3a-4c35-98f9-72b4880a1e98)
### 산술연산 명령어
- cmpl 명령어는 subl 명령어와 동일하게 처리하지만 뺄셈의 결과를 목적지 오퍼란드에 저장하는 작업만을 생략한다.
- FLAGS 레지스터의 각종 플래그 비트들의 값에 따라 분기 여부가 결정된다.
- FLAGS 레지스터는 16비트(초기 x86 CPU에서 사용됨), EFLAGS 레지스터는 32비트(FLAGS를 확장한 버전), RFLAGS 레지스터는 64비트(EFLAGS를 또 확장한 버전) 시스템에서 사용된다.
### 스택 처리 명령어
- 스택은 기본적으로 높은 주소가 바닥 쪽을 의미하고, 낮은 주소 부분이 꼭대기 쪽을 의미한다.
- ESP(Extended Stack Pointer): x86 32비트 시스템에서 사용하는 스택 포인터 레지스터로, 스택의 top(맨 위 주소)을 가리킨다.<br>
32비트 시스템에서는 레지스터나 일반 데이터가 대부분 4바이트 크기로 저장된다.
- PUSH: 스택에 쌓는 명령어로서, ESP를 4만큼 줄인 후에 ESP(Extended Stack Pointer)가 가리키는 주소에 쌓고자 하는 값을 기록한다.
- POP: 스택에서 꺼내는 명령어로, ESP가 가리키는 주소에서 읽어내어 대상 오퍼란드에 저장하고 ESP를 4만큼 증가시킨다.
- **Push, Pop 명령어를 사용하면 왜 ESP가 4만큼 증감하는 것인가?**
  - x86 32비트 시스템에서 스택은 4바이트(= 32비트) 단위로 작동하기 때문이다.
  - 스택은 메모리에서 위에서 아래로(높은 주소 → 낮은 주소) 자라기 때문이다.
### 함수호출 및 복귀 명령어
- **CALL**: 함수호출 명령어로서, 다음 명령어의 주소(현재의 EIP 레지스터 값)를 스택에 쌓아서 (PUSH로 기록) 복귀할 주소를 저장한 후에 EIP 레지스터에 지정한 함수 주소를 기록함으로써 지정된 함수의 주소에 있는 명령어를 실행하게 된다.
- **RET**: 함수로부터의 복귀 명령어로서, 스택으로부터 꺼낸(POP으로 읽어온) 값을 EIP 레지스터에 기록함으로써 함수를 호출할 당시에 저장한 주소의 명령어로부터 실행을 계속하게 된다.

![image](https://github.com/user-attachments/assets/ea946c48-9621-4fb8-a11a-9ff8c536a04a)
### 함수의 파라미터 전달
- OS를 구현하기 위해서는 부분적으로 어셈블리어 언어를 사용하여 작성하고, C언어로 작성된 부분들과 하나로 결합하여 하나의 커널 파일을 생성해야 한다.
- 이 과정에서 어셈블리 언어로 작성된 파일과 C언어로 작성된 파일을 링크하게 되는데, 함수를 호출할 때 파라미터들을 전달하고, 반환 값을 받는 방식이 서로 일치해야 한다.
- 컴파일러마다 차이가 있기 때문에 컴파일러의 특성을 감안하여 어셈블리 언어 프로그램을 작성해야 한다.
### gcc에서 파라미터 전달 방식
- gcc 컴파일러는 함수를 호출할 때 파라미터들을 역순으로 스택에 저장하고 되돌아올 주소를 스택에 저장한 후에 해당 함수로 이동하는 방식을 사용한다.
- 그림에서도, abs 함수의 첫 명령어를 실행하는 시점에는 스택 포인터인 ESP 레지스터가 가리키는 곳에는 되돌아갈 주소가, ESP + 4 주소에는 abs 함수의 파라미터 값이 각각 들어있게 된다.
- gcc는 함수의 반환 값을 EAX 레지스터에 저장하는 것으로 처리한다.
- 따라서, abs 함수에서 ret 명령어가 실행되기 전에 반환 값이 EAX 레지스터에 들어 있도록 하고 있다.
### 함수 호출 및 반환값 처리
- 그림처럼, C언어로 작성된 프로그램에서 abs 함수를 사용하여 "value = abs(x);"로 작성된 부분이 있다하면, gcc 컴파일러는 그림의 코드처럼 번역할 것이다.
- 먼저, 변수 x의 값을 스택에 쌓은 후에 abs 함수를 호출하고 abs에서 반환된 후에 EAX 레지스터의 값을 변수 value에 복사한다.
- 변수 x를 스택에 쌓으면서 ESP 값이 4만큼 줄어 있으므로 다시 4만큼 증가 시켜주어야 원래의 스택 위치로 복구된다.

![image](https://github.com/user-attachments/assets/a4422fb3-5c14-4dbe-8158-b998effa9cec)
![image](https://github.com/user-attachments/assets/ca80f5fc-7e8d-4647-9d70-4d2be804be49)
- C언어 & 어셈블리어가 합쳐지는 과정
- abs 함수를 호출하면서 파라미터를 스택에 쌓은 후에 'call abs'를 실행하면, abs의 함수의 주소로 이동해 와서 스택으로부터 전달된 값을 EAX로 읽어내어 검사한다.
- 값이 양수면 그대로, 아니면 부호를 양으로 바꾼 후에 ret 명령어에 의해 함수를 호출한 주소로 복귀한다.

![image](https://github.com/user-attachments/assets/240882db-d717-403c-9160-faa86002ae54)
- 예를 들어, 다음과 같다
  - gcc test.c → Child File 생성
  - gcc -c main.c → main.o
  - gcc -c test.c → test.o  
## 커널 모드 & 유저 모드
![image](https://github.com/user-attachments/assets/25a9a37b-85f2-4084-97b9-30e765e52bed)
### 모드의 구분을 분명히 해야한다.
- CPU는 단순히 명령어를 읽어 오고, 이를 실행하는 것을 반복하지만, 실행되는 내용이 운영체제 부분인지 프로세스 부분인지에 따라 실행 권한이 달려져야한다.
- OS 부분이 실행되고 있는 시점에는 아무런 제약이 없이 시스템 전체의 임의의 메모리와 하드웨어를 접글할 수 있어야 하지만, 프로세스 부분이 실행되고 있는 시점에는 프로세스 자신에게 할당된 메모리 부분에 한해서 읽기나 수정이 가능하고 나머지 부분은 접근이 금지되어야 한다.
- 즉, CPU는 명령어들을 실행할 때, 운영체제 부분이 실행될 때와 프로세스 부분이 실행될 때를 구분할 수 있어야 한다.
- **Why?**
  - 보안(Security)
    - 사용자가 직접 하드웨어 자원(CPU, 메모리, 디스크 등)에 접근하면, 시스템 전체를 망가뜨릴 수 있다.
  - 안정성(Stability)
    - 운영체제는 시스템 전체를 관리하므로, 사용자 코드가 운영체제의 코드나 데이터를 손상시키면 시스템이 다운되거나 오작동 할 수 있다.
### 커널 모드(Kernel Mode)
- 운영체제 부분이 실행되고 있을 때의 CPU 상태를 나타낸다.
- System Mode, Supervisor Mode, Privileged Mode 등으로도 불린다.
### 유저 모드(User Mode)
- 프로세스 부분이 실행되고 있을 때의 CPU 상태를 나타낸다.
- ARM 계열의 프로세서는 PSR(Program Status Register)에 모드를 표시하는 5비트(b4 ~ b0)가 있는데, 이 부분의 값이 '10000'일 때에만 유저 모드이고, 나머지는 약간씩 다른 의미를 가지는 커널 모드들을 의미한다.
![image](https://github.com/user-attachments/assets/305be2ee-9ec1-4399-8181-b5fd754dd137)

### CPU의 모드 구별
- CPU는 커널 모드와 유저 모드를 표시하는 특수 레지스터를 가지고 있다.  
![image](https://github.com/user-attachments/assets/ed160db5-26f0-4dde-bb21-ca8aaf350e3d)
- 펜티엄 프로세서(인텔이 개발한 프로세서)에서 그림의 (a)와 같이 Descriptor 레지스터의 PL(Privilege Level) 2비트가 이 용도로 사용된다.
- 이것을 이용하여 모드를 4 단계로 분류하고 낮은 수준의 모드에서는 높은 수준의 모드를 위한 코드 부분과 데이터 부분을 사용하지 못하도록 처리한다.
- 이 값이 0일 때 가장 높은 수준의 모드이며, 3일 때가 가장 낮은 수준의 모드이다.
- 리눅스의 경우에는 커널이 실행될 때에는 (커널 모드) 이 값을 0으로 설정하고, 프로세스가 실행될 때에는 (유저 모드) 이 값을 3으로 설정한다.
- 수준 1과 2의 값은 리눅스에서 사용하지 않는다.
- 펜티엄에서는 그림 (b)와 같이 EFLAGS 레지스터의 IOPL (I/O privilege Level) 2비트도 사용되는데, IOPL의 값이 0일 때에만 인터럽트의 금지나 허용을 위한 명령어를 실행할 수 있도록 설계되어 있다.
### 메모리 영억 제한
- 시스템 보호를 위해서는 CPU의 모드에 따라서 접근할 수 있는 메모리 영역을 제한할 수 있어야 한다.
- 커널이 실행되고 있는 커널 모드에서는 모든 메모리 영역에 접근할 수 있지만, 특정 프로세스를 실행하고 있는 유저 모드에서는 이 프로세스에게 할당된 메모리 영역에 한해서만 접근할 수 있도록 해야 한다.
### 특권 명령
- CPU는 커널 모드에서만 실행 가능한 명령어(특권 명령, Privileged Instruction) 집합을 별도로 가지고 있는데, 상태 레지스터의 모드 부분 변경이나 인터럽트 금지 및 해제 등을 위한 명령어들이 이 범주에 속한다.
- 만약, 유저 모드에서 이런 특권 명령을 실행하면 실행 모드 위반의 인터럽트가 발생하고 운영체제는 그 처리 루틴에서 실행되던 프로세스를 강제로 종료시킨다.

## 모드 전환
![image](https://github.com/user-attachments/assets/88e9f2f3-172d-4681-b206-4184c1f6bb3e)
- 프로세스 부분이 실행되고 있는 동안에는 유저 모드를 유지하고 있다가 커널 부분을 실행할 때는 커널 모드로 전환되어야 한다.
- 커널 부분의 실행을 마치고, 프로세스 부분의 실행으로 돌아오면 CPU의 모드도 유저 모드로 다시 전환되어야 한다.
- 커널 모드에서 유저 모드로 바꾸는 것은 모드를 표시하는 비트들을 유저 모드를 의미하는 값으로 변경하면 된다.
- 그러나, 반대로 유저 모드에서 커널 모드로 변경하는 과정에서는 이 비트들을 임의로 변경할 수가 없다.
- 이 작업은 특권 명령 범주에 포함되어 있어서 유저 모드에서는 실행할 수 없도록 하고 있기 때문이다.
- 대신에 대부분의 프로세서들은 인터럽트가 발생하면 무조건 커널 모드로 전환되도록 설계되어 있다.
- 유저 모드에서 모드 비트 부분을 임의로 변경할 수 있다면, 프로세스들은 언제라도 커널 모드로 전환하여 아무런 제한이 없이 메모리나 하드웨어를 조작할 위험이 있다.
- 따라서, 상태 레지스터의 모드 부분을 변경하는 명령어는 커널 모드에서만 실행이 가능한 특권 명령으로 프로세서가 설계되어 있다.
### 커널 모드로의 전환
- 프로세서들은 인터럽트가 발생하면, 커널 모드로 전환되고, 커널 부분에 미리 등록된 인터럽트 처리 루틴(ISR: Interrupt Service Routine)을 실행하도록 설계되어 있다.
  - **인터럽트 처리 루틴(ISR: Interrupt Service Routine)**: 컴퓨터 시스템에서 발생하는 인터럽트에 대응하여 시스템이 취해야 하는 동작을 정의한 코드 블록 
- 따라서, 유저 모드에서 프로세스가 실행되다가 커널 부분을 실행하야 할 경우에는 강제로 인터럽트를 발생시키는 명령어를 실행함으로써 커널 모드로 전환할 수 있다.
- 이렇게 특정 명령어에 의해 의도적으로 발생시키는 인터럽트를 **소프트웨어 인터럽트(Software Interrupt)**라고 한다.
### 유저 모드로의 복귀
- 인터럽트가 발생하면 당시의 모드 값을 스택이나 특정 레지스터에 저장해 두었다가 인터럽트로부터 복귀하는 명령어에 의해 인터럽트 처리 루틴에서 원 상태로 복귀할 때, 이 모드 값도 복구하도록 한다.
- 따라서, 커널 모드에서 유저 모드로 전환할 때에는 모드 비트 부분을 강제로 설정하기보다는 일반적으로 "iret" 명령어를 통하여 원래의 모드로 복귀하는 방법을 사용한다.
### 인터럽트 발생
- 인터럽트는 여러 가지 원인에 의해서 발생하는데 소프트웨어 인터럽트 외에도 하드웨어로부터 발생하는 하드웨어 인터럽트와 명령어들의 실행 중에 발생하는 오류에 의한 예외처리 등이 있다.
- 하드웨어 인터럽트는 특정 장치로부터 CPU로 전달하는 신호에 의해 발생한다.
- 명령어 오류에 의한 예외로는 정의되지 않은 명령어의 실행, 나눗셈에서 0으로 나누기, 특권 명령을 실행할 때의 실행 모드 위반 등이 있다.
### 인터럽트 처리
- 인터럽트가 발생하면, CPU는 다음에 실행할 명령어의 주소와 실행 모드 등을 스택이나 특정 레지스터에 기록한 다음, 인터럽트가 발생한 원인에 따라 미리 등록된 인터럽트 처리 루틴으로 이동하여 실행한다.
- 그리고, 그 루틴의 끝 부분에 있는 인터럽트로부터의 복귀를 위한 명령어를 실행하게 되면 인터럽트가 발생한 시점의 실행 위치 및 실행 모드로 복귀하여 이전의 실행을 계속한다.
- 이 과정에서 인터럽트 처리 루틴을 실행하는 중에는 무조건 커널 모드로 실행된다.

## LINUX의 Write 함수
![image](https://github.com/user-attachments/assets/f3ae23da-acd7-4aa1-86ae-05ae8eeec42d)
### 시스템 콜 함수(System Call Function)
- 운영체제의 특정 기능의 실행을 요청하는 함수이다.
- 일반 함수가 호출될 때에는 CPU의 모드 변경 없이 해당 함수로 이동하여 실행하고, 다시 원래의 위치로 돌아와서 실행을 계속한다.
- 시스템 콜 함수의 경우에는 CPU의 실행 모드를 커널 모드로 변경해야 하므로 소프트웨어 인터럽트를 이용하여 그 인터럽트 처리 루틴에서 지정된 함수를 처리하고 원래 위치로 돌아오도록 한다.
- 예를 들어, 쓰기를 위한 시스템 콜 함수인 write는 어셈블리 언어로 작성되어 있는데 전달받은 파라미터들을 CPU의 레지스터들에 적절히 저장한 다음, 소프트웨어 인터럽트를 발생시키는 명령어를 실행하도록 되어 있다.

- **Wrapper 함수**: 시스템 콜 함수를 간편하게 호출할 수 있도록 제공해 주는 함수
### Linux System의 시스템 콜 함수 동작 과정
1. 사용자 프로세스에서 시스템 콜 호출
2. 유저 모드 → 커널 모드
3. 시스템 콜 인자 복사
4. 커널 내부에서 적절한 시스템 콜 함수 실행
5. 시스템 콜 함수 결과 반환
6. 커널 모드 → 유저 모드

![image](https://github.com/user-attachments/assets/bc44b711-0e63-4950-a2e0-9ab7b097830e)

### 시스템 콜 반환값 처리
- 실행 과정에서 오류가 있으면, 음수 값인 오류 코드를 반환 값으로 설정한다.
- write 시스템 콜 함수로부터 반환된 후에 EAX에 저장된 반환 값을 검사하고, 이 값이 음수이면 오류를 나타내므로 그 값의 부호를 양수로 바꾸어서 전역 변수 errno에 저장하고 EAX 레지스터의 값을 -1로 설정함으로써 write 함수의 반환 값이 -1 되도록 한다.
- 오류가 없을 경우에는 EAx 레지스터에는 실제 write 작업을 실행한 바이트 수가 기록되어 있고, 이 값을 그대로 write 함수의 반환 값이 되도록 한다.

## 여러 파일의 링크 과정
![image](https://github.com/user-attachments/assets/7fb3455e-ca54-4f35-8a31-d4d2e13874bd)
- C언어로 작성된 test.c 파일에는 write() 함수를 호출하고, 어셈블리 언어로 작성된 write.s 파일에는 write 함수가 들어 있다면 이들을 컴파일하고 하나의 실행파일로 결합하는 과정은 다음과 같다.(GNN C 컴파일러와 어셈블리 언어 기준)
  1. test.c 파일을 컴파일하여 test.o 파일을 생성한다.(gcc -c test.c 명령어 실행)
  2. write.s 파일은 어셈블링을 통하여 write.o 파일을 생성한다.
  - 이 과정은 어셈블러인 as를 이용하여 "as write.s" 명령어로 실행하거나 gcc를 이용하여 "gcc -c test.s" 명령어를 실행한다.
  - 이제 test.o 파일과 write.o 파일을 하나로 결합하여 실행파일인 test를 생성하는 과정은 링키지에디터인 ld를 이용하여 "ld -o test test.o write.o" 명령어로 실행하거나 gcc를 이용하여 "gcc -o test test.o write.o" 명령어를 실행한다.
    - **링키지 에디터**: 컴파일러가 생성한 하나 이상의 목적 파일(Object File)을 가져와 이를 단일 실행 프로그램으로 병합하는 프로그램
  - 링키지 에디터인 ld는 test.o 파일의 code 부분과 write.o 파일의 코드부분을 결합하여 test 파일의 code 부분으로 생성하고, 각각의 data 부분도 결합하여 test 파일의 data 부분으로 생성한다.
    - gcc: GNU Compiler Collection(다양한 프로그래밍 언어를 위한 컴파일러 모음)
      - 그 자체가 컴파일러가 아닌 컴파일과 링크 과정을 총괄하여 처리하는 유틸리티 프로그램이다.
      - 만약, 지정된 파일 이름이 ".c"로 끝나면 먼저 실제 C 컴파일러를 자식 프로세스로 생성하여 컴파일 작업을 시키고 그 출력인 어셈블리 언어 파일은 다시 어셈블러를 자식 프로세스로 생성하여 어셈블 작업을 실행시킨다.
      - 파일 이름이 ".s"로 끝나면, 컴파일 과정은 생략하고 어셈블러 프로세스를 생성하여 실행한다. 컴파일과 어셈블 작업이 끝나면 이들을 하나로 결합하기 위해서 링키지 에디터인 ld를 자식 프로세스로 생성하여 실행시킨다.  
  - test.o 파일에는 write 함수를 호출하지만 write 함수 자체는 없으므로 write 함수의 주소 부분은 빈 상태이다.
  - 반대로, write.o 파일에는 변수 errno를 사용하지만 변수 자체는 다른 파일에 포함되어 있으므로 이 부분이 빈 상태이다.
  - 이들이 결합되어 생성된 파일인 test에는 함수 write를 호출하는 부분과 write 함수 자체, 변수 errno를 사용하는 부분과 errno 변수 자체가 모두 포함되고 이들에 대한 주소도 결정된다.
  - 각 파일의 head 부분은 파일의 주요 정보를 기록하고 있는데, 파일의 형식 종류, code 부분의 시작 위치와 크기, data 부분의 시작 위치와 크기 등에 대한 정보가 포함된다.

## 인터럽트 발생과 커널 실행
![image](https://github.com/user-attachments/assets/7f3fc4c6-e443-4e13-a174-bfaeb0116d86)
### 인터럽트와 실행위치 이동
현재 프로세스 A가 실행 중이라고 가정할 때,
① CPU는 유저 모드에서 프로세스 A의 코드가 저장된 메모리 부분에서 명령어를 읽어 오고 실행한다.
② 하드웨어 인터럽트가 발생하거나 프로세스 A 자신이 시스템 콜 함수를 호출하면서 소프트웨어 인터럽트가 발생한다.
③ ②이 발생하면, 커널 모드로 전환되면서 대응되는 인터럽트 처리 루틴(ISR)을 실행한다.
④ 정상적으로 ISR이 완료되면, ISR의 끝부분에 있는 iret 명령어를 실행하면서 인터럽트가 발생할 당시의 모드 및 실행 위치로 되돌아간다.
⑤ 프로세스 A가 계속 실행된다.
## 인터럽트와 문맥교환
![image](https://github.com/user-attachments/assets/025122a2-0c6c-4a8a-81c8-1fbfcc7e66a5)
- ISR을 실행하는 도중에 스케줄링에 의해 필요하면 다른 프로세스로 전환될 수 있다.
① 프로세스 A가 실행된다.
② 파일 읽기를 요청한다.
③ 그 시스템 콜 함수를 처리한다.
④ 프로세스 A는 읽기가 완료될 때까지 실행을 할 수가 없으므로, 대신 실행 가능 상태인 프로세스 B의 실행 위치로 이동한다.
⑤ 프로세스 B를 실행한다.
⑥ 프로세스 B가 실행되는 도중에, 파일 읽기가 완료되어서 디스크 제어기로부터 하드웨어 인터럽트가 발생한다.
⑦ 해당 ISR을 실행하는 과정에서 프로세스 A의 상태를 실행 가능 상태로 전환한다.
⑧ 이때, 프로세스 A의 우선순위가 높다면, 바로 프로세스 A의 실행 위치로 이동한다.
⑨ 프로세스 A는 파일 읽기 시스템 콜 함수로부터 반환되어 실행을 계속한다.
### 인터럽트 복귀
- 프로세스 A로 다시 전환되면, 프로세스 A에서 프로세스 B로 전환될 당시의 모드 (커널 모드)와 실행하던 위치 (호출했던 소프트웨어 인터럽트에 대한 ISR 실행 중)로 실행 위치가 복구되고 최종적으로 프로세스 A에 의한 소프트웨어 인터럽트로부터 iret의 명령어에 의해 시스템 콜 함수 호출 당시의 모드 (유저 모드)와 실행 위치로 복귀한다.
## 커널 내부의 인터럽트 처리
![image](https://github.com/user-attachments/assets/baa42035-ded7-47d8-ba22-bb8a52a63180)
- 인터럽트가 발생할 때, 프로세서가 처리하는 작업은 프로세서 마다 독특한 방식을 따르지만 목적은 유사하다.
- 인터럽트의 처리를 위한 프로그램 부분을 먼저 실행한 후에 다시 원래의 위치로 복귀하여 실행을 계속할 수 있도록 해야 한다.
- 이를 위해서는 먼저 인터럽트가 발생할 당시의 모드와 다음 명령어의 주소를 지정된 장소에 복사한 후에 모드를 커널 모드로 전환하고, 실행할 주소는 인터럽트 원인별로 지정된 주소로 변경한다.
- 인터럽트 처리를 위한 프로그램의 끝 부분에는 반드시 인터럽트로부터 원래의 상태로 복귀하기 위한 명령어가 있는데, 이 명령어는 저장된 모드와 다음 명령어의 주소를 복구하는 작업을 하는 것이다.
## x86 인터럽트 처리 절차
![image](https://github.com/user-attachments/assets/e71ad159-0a9f-417c-a540-8f3396284ebf)
- 펜티엄 프로세서를 포함한 x86 계열의 프로세서들은 인터럽트가 발생하면 현재의 모드를 먼저 스택에 푸시하고, IP 레지스터(다음 명령어의 주소가 들어있음) 값을 스택에 푸시한 다음에, 모드는 커널 모드로 변경한다.
- 다음에 인터럽트 종류 번호에 4를 곱한 주소를 사용하여 메모리에서 읽어온 값을 IP에 기록한다.
  - 0번 인터럽트는 0번지에서 4바이트를, 1번 인터럽트는 4번지부터 4바이트를 읽어오면 그 값이 다음에 실행할 명령어의 주소가 된다.
- 시스템 콜 함수를 호출하기 위해서 "int $0x80"을 실행하면 인터럽트가 발생하면서 0x80 x 4 = 0x200 번지의 메모리 내용을 읽어 와서 IP에 저장한다.
- 운영체제에는 인터럽트 종류별로 처리하는 프로그램이 포함되어야 하고, 0번지부터 시작하는 적절한 메모리 영역에는 이들의 주소가 기록되어 있어야 한다.
- 이러한 작업은 운영체제의 초기화 부분에서 처리되도록 적절하게 운영체제의 프로그램에 표현되어야 한다.
  
- 인터럽트로부터 복귀하기 위한 명령어인 iret의 처리과정은 인터럽트가 발생할 때 처리하는 과정의 역순으로 이루어진다.
- 먼저, 스택에서 pop하여 IP에 기록하고, 다시 한번 pop하여 프로세서의 모드에 기록한다.
- 따라서, 프로세서는 인터럽트가 발생할 당시의 모드와 실행위치로 복귀하는 것이다.

![image](https://github.com/user-attachments/assets/6e659cb6-d51d-4edf-ba02-ac8146e87b82)
