# 컴퓨터 구조와 어셈블리 언어(2장)
![image](https://github.com/user-attachments/assets/15cd8e2b-8ec6-4da6-b072-0b88999829c4)
- 위 그림은 하드웨어 회로 상에서 주소가 할당된 예를 보여준다.
- CPU는 각 장치를 담당하는 제어기(Controller)에 적절한 명령을 전달하고, 그 결과를 읽어온다.
- 각 입출력 제어기에는 CPU로부터 명령을 받고 결과를 반환하기 위한 주소가 할당되어 있는데, 이것은 하드웨어 설계 단계에서 설계자가 적절히 선택하여 설계에 반영한다.
### CPU(Central Processing Unit)
- 중앙 처리 장치로서, 연산, 제어, 입출력 관리, 명령 해석, 메모리 접근 등을 수행하는 컴퓨터 시스템의 핵심 부품
### 데이터 흐름
1. 메모리에서 명령어나 데이터를 읽어온다.
2. CPU가 그것을 해석하고 처리한다.
3. 필요 시, 입출력 장치 제어기(I/O Controller)에 명령을 전달한다.
4. 입출력 장치와의 데이터 송수신을 담당하는 건 제어기(Controller)이다.
### 시스템 버스(System Bus)
- 버스는 단순 선이 아닌, 데이터 전송을 위한 신호들의 묶음이다.
  ### 세 가지 구성 요소
  - 주소 버스(Address Bus): 어디(메모리나 장치)에 접근할 것인지 주솔르 지정한다.
  - 데이터 버스(Data Bus): 실제 데이터를 전달한다.
  - 제어 버스(Control Bus): 읽기/쓰기 신호, 인터럽트, 클럭 등 제어 신호를 전달한다. 
## 주소 디코딩
- 주소 버스(Address Bus)의 값을 받아, 특정한 메모리 블록 또는 입출력 장치를 선택하는 회로이다.
- 즉, CPU가 특정 주소에 접근했을 때 그 주소가 어떤 장치에 해당하는지를 판단하고, 해당 장치에 연결된 회로만 활성화(선택)된다는 의미이다.
- 각 구성모듈들에 대해 일정한 주소 영역이 할당되어 있어서 CPU로부터 주소가 나오면 구성모듈들 중에서 오직 하나만이 선택되어 활성화된다.
- 주소 디코더(Address Decoder)들은 할당된 주소에 맞게 조합 논리회로(현재 입력에 따라 출력이 항상 똑같이 결정되는 논리회로)로 구성되는데, 할당된 주소영역이 적용될 때에만 출력을 활성화하여 해당 모듈이 활성화 되도록 한다.

![image](https://github.com/user-attachments/assets/dbeb738a-3119-4171-bb35-58b3098c0dc2)

### 주소 맵(Address Map or Memory Map)
- 각 모듈별로 할당된 주소의 집합

![image](https://github.com/user-attachments/assets/a8ede196-864c-4cdd-91f8-167cff692d05)

- A(19-0): 20개의 구리선으로 구성된다.
- 예를 들어, 주소 맵이 RAM은 0x00000번지부터 0x3ffff번까지 256K 바이트 크기를 가지고, ROM은 0x40000 번지부터 0x4ffff번지까지 64K 바이트의 크기를 가지며, I/O 장치는 0x80000번지부터 0x80003번지까지 4바이트의 크기를 가질 경우를 가정하면 각 대상별 주소 범위는 위의 첫째 그림과 같고 이에 따른 주소 디코더는 위의 그림과 같이 구성 할 수 있다.

![image](https://github.com/user-attachments/assets/cab51f7b-b506-4ca1-bf3a-613f4eb9f37e)

## 입출력 장치 제어
![image](https://github.com/user-attachments/assets/ae051509-52bf-49c6-8fb2-8c565141a0f0)
- 명령전달: 장치의 종류에 상관없이 보낼 수 있다.
- 작업완료 확인:
  - Polling(장치의 상태 메시지를 계속 확인한다.)
  - Interrupt
- 데이터 입출력 

### 입출력 장치 제어기를 구성하는 요소
- **제어 레지스터**: CPU로부터 명령을 받아들인다.
- **상태 레지스터**: 장치의 상태를 나타낸다.
- **데이터 레지스터**: 입출력 데이터를 처리한다.
### 입출력 장치 제어는 어떤 원리로 작동하는가?
1. CPU가 특정 입출력 장치 제어기의 제어 레지스터에 특정 명령을 의미하는 값을 기록한다.
2. 해당 제어기는 그 값을 확인하고, 지정된 작업을 수행한 후에 결과를 상태 레지스터에 기록해 둔다.
3. CPU는 이것을 읽어내어서 작업 결과를 확인할 수 있게 되며, 입출력 데이터 자체는 데이터 레지스터 부분을 읽거나 기록하는 것으로 처리한다.

### 작업 완료 확인 방법
1. **폴링(Polling)**
  - CPU는 명령을 전달한 후에 반복적으로 상태 레지스터를 읽어 보고 완료 여부를 확인한다.
  - 실행이 완료될 때까지 계속 검사를 해야 하므로 인터럽트 방식에 비해 시간 낭비를 초래한다.**(폴링 방식의 단점!)**
2. **인터럽트(Interrupt)**
  - CPU는 명령을 전달한 후에 작업이 완료될 때까지 다른 프로세스를 실행한다.
  - 명령을 받은 제어기는 지시받은 작업이 완료되는 시점에 CPU에 인터럽트 신호를 발생시킨다.
  - 이 신호에 따라 CPU는 해당 인터럽트 처리 루틴을 실행하게 되고, 여기서 작업 결과를 확인하는 절차를 실행한다.

## Direct Memory Access
![image](https://github.com/user-attachments/assets/3dab4505-7604-45b6-8fbb-35327d3da3b5)
- 기능이 있는 입출력 장치 제어기의 동작 과정
  1. CPU가 제어기로 명령을 전달해 놓는다.
  2. 제어기에서는 전달받은 명령에 따라 입출력 작업을 직접 메모리에 읽기나 쓰기 작업으로 처리한다.
  3. 작업이 완료된 시점에 CPU에게 인터럽트 신호를 발생시킨다.
  → CPU는 인터럽트 신호가 발생하면 그 처리 과정에서 입출력 작업 완료 후에 해야 할 작업을 진행하게 된다. 

- 디스크 입출력과 같이 한번에 대량의 데이터를 처리해야 하는 경우, 매 데이터 단위마다 CPU가 명령을 전달하고, 결과를 받는 과정을 거친다면 실행 속도가 많이 느려지게 된다.
- 인터럽트 신호는 장치마다 우선순위가 있는데, 장치 레벨이 높은 하드웨어에 먼저 우선순위가 부여되고, 장치레벨이 같다면 먼저 신호가 들어오거나 우선순위가 높은 인터럽트 신호가 먼저 처리된다.
- 여러 개의 인터럽트가 동시에 발생하면, 인터럽트 컨트롤러가 우선순위를 결정하여 CPU에 전달하고, CPU는 그 순서에 따라 인터럽트를 처리한다.
### DMA 제어기(DMAC: Direct Memory Access Controller)
- 이러한 반복적인 작업을 전담하는 장치로서, 입력 작업을 위해서는 직접 주변 장치의 제어기로부터 데이터를 받아서 메모리의 지정된 영역에 차례대로 기록하고, 출력 작업을 위해서는 그 반대의 작업을 실행한다.
- 즉, 메모리에는 CPU뿐만 아니라 DMAC도 읽거나 쓰기 작업을 실행한다.

## 디스크 제어기의 DMAC(디스크 제어기 명령전달 절차)
![image](https://github.com/user-attachments/assets/63d970bc-c8fa-4d57-af98-b1f290af8919)
- 디스크 제어기의 제어 레지스터는 4개로 구성되는데, 0x80000 번지는 읽기(1)와 쓰기(2)를 구별하는 값, 0x80001 번지는 디스크 블록 번호, 0x8002 번지는 메모리 주소, 0x80003 번지는 바이트 수를 기록한다고 가정한다.
- 인터럽트 신호가 들어오면 OS 내부에서 처리된다.
- 프로세스 P2가 int 명령어를 통하여 디스크의 200번 블록에서 1024 바이트를 읽어서 메모리의 0x5100 번지부터 채우라는 파일 읽기 요청을 한다면,
  OS에서는 디스크 제어기에 다음과 같은 방법으로 명령을 전달한다.
  1. **mov $200, 0x80001**: 디스크 블록번호 레지스터에 200을 기록한다.
  2. **mov $0x5100, 0x80002**: 메모리 주소 레지스터에 0x5100을 기록한다.
  3. **mov $1024, 0x80003**: 크기 레지스터에 1024를 기록한다.
  4. **mov $1, 0x80000**: 읽기를 표시하는 값을 기록한다.
  5. 그러면, 디스크 제어기는 DMAC를 활용하여 지정된 작업을 완료한 후에 CPU에 인터럽트 신호를 보내게 된다.

## 프로세서의 프로그래밍 모델(ARM, X86)
![image](https://github.com/user-attachments/assets/5b7be54f-04a8-4dbe-b098-6d280991956e)
- 각종 하드웨어 장치를 제어하는 기능을 구현하는데 있어서 부분저긍로 고급 언어로는 표현이 불가능한 내용들이 있고, 이러한 부분은 어셈블리 언어로 표현하여야 한다.
- 따라서, 하나의 OS를 완성하는데 있어서 대부분 고급 언어를 사용하여 작성하고, 부분적으로는 어셈블리 언어로 작성하며, 이들을 하나로 결합하여 커널 파일로 완성해야 한다.
- 이렇게 작성된 커널 파일은 부팅 과정에서 메모리에 적재되어 실행된다.

## 8086 Processor 내부 구조(CPU 내부 동작 과정 / 16bit)
![image](https://github.com/user-attachments/assets/938b4c34-7a9d-459b-9352-a141a6decf61)
- 8086은 펜티엄의 선조에 해당하는 것으로서 비교적 간단하고 일반적인 PC에서 간편하게 사용해볼 수 있는 프로세서이다.
### 핵심 구성 요소 및 역할
- IP(Instruction Pointer): 다음에 실행할 명령어 주소를 저장
- Control Unit: 명령어 해석 및 제어 신호 생성
- ALU: 실제 산술/논리 연산 수행
- FLAGS: 연산 결과 상태 저장
- 레지스터(AX, BX 등): 데이터 임시 저장
- Address, Data Bus: 메모리와의 주소/데이터 송수신
- SP(Stack Pointer): 현재 스택의 최상단 주소를 가리킨다.(함수 호출, 지역 변수 저장, 함수 복귀 시 사용된다.)
- LR(Link Register): 함수 호출(Branch with Link, BL) 시 돌아올 주소를 지정한다.(즉, 함수가 끝난 뒤 어디로 복귀해야 할 지를 기억하는 역할)
- PC(Program Counter): 현재 실행 중인 명령어의 주소를 저장한다.(명령어가 실행될 때마다 자동으로 다음 주소로 증가한다.)
### 8086 프로세서 내부에서 명령어가 수행되는 과정
1. Instruction Fetch(명령어 가져오기)
- IP는 현재 실행할 명령어의 메모리 주소를 가지고 있다.
- 이 주솔르 Address 버스를 통해 외부 메모리에 전달한다.
- 해당 주소의 명령어가 Data Bus를 통해 내부로 들어온다.
2. Control Unit 처리
- 명령어가 들어오면 Control Unit이 이를 해석한다.
- 어떤 연산을 해야 하는지, 어떤 레지스터를 사용하는지 등 명령의 종류에 따라 다음 단계를 지시한다.
3. Operand 처리
- Control Unit의 지시에 따라 레시스터 파일(AX, BX, CX, DX 등)에서 피연산자(Operand)를 가져온다.
- SI, DI, BP, SP 등은 주소 계산이나 스택 조작 등에 사용된다.
4. 연산 수행
- 피연산자는 ALU(Arithmetic Logic Unit)로 전달된다.
- ALU는 덧셈, 뺄셈, AND/OR 등의 산술/논리 연산을 수행한다.
- 결과는 다시 레지스터에 저장되거나, 외부 메모리로 전달될 수 있다.
5. 플래그 갱신
- ALU 연산 결과에 따라 FLAGS 레지스터가 갱신된다.
- 예: 결과가 0인지, 캐리 발생 여부, 부호 등 
6. Instruction Pointer 증가
- 명령어가 끝나면 IP가 명령어 길이만큼 증가한다.
- 다음 명령어를 실행할 준비를 한다.
### 프로세서(Processor)
- CPU 기능을 하나의 칩으로 제작한 것으로, 하나의 작은 칩으로 제작되기 때문에 마이크로프로세서(Micro-Processor)라고 부르기도 하고, 이 칩에 여러 가지 부가 기능들이 추가되기도 한다.(CPU = Processor = Micro-Processor)
- 고급 언어로 작성된 부분은 사용하는 프로세서에 상관없이 컴파일러에 의해 자동으로 적절한 기계어 코드로 번역되지만, 어셈블리 언어로 작성하는 부분은 특정 프로세서에 맞게 작성해야 한다.(특히, 어셈블리 언어는 표준이 없으므로, 어셈블러마다 약간씩 차이가 있을 수 있다.)
### 레지스터(Register)
![image](https://github.com/user-attachments/assets/24627a5c-af96-4e50-8aab-8187106b38f8)
- Program Status Register: 오버플로우, 캐리, 음수 등 발생 시, 해당 내용을 저장하는 레지스터
- 어셈블리 언어로 작성된 프로그램은 프로세서 내부의 레지스터들을 적절히 활용하면서 메모리의 내용들과 레지스터들 간에 데이터를 이동하거나 연산 작업을 하는 것으로 표현한다.
- 프로그램이 실행되는 과정을 제어하기 위해서는 연산 결과에 따른 상태 조건에 의해 실행 위치를 분기하여 이동하는 작업 및 함수를 호출하고 결과를 반환하는 작업 등을 한다.
## C 언어, 어셈블리 언어, 기계어
![image](https://github.com/user-attachments/assets/416029c5-6cfe-4b01-a721-d871012d7741)
![image](https://github.com/user-attachments/assets/212cd8da-bbce-496e-a318-889e757b1d14)
### 위의 그림 분석
- **mov sum, %ax**: sum 변수가 있는 주소의 메모리 내용을 읽어서 프로세서 내부의 AX 레지스터에 기록한다.
- **add index, %ax**: index 변수가 있는 주소의 메모리 내용을 읽어서 AX 레지스터에 더한다.
- **mov %ax, sum**: 현재의 AX 레지스터의 내용을 sum 변수의 메모리 부분에 기록한다.
→ 이렇게 3개의 명령어를 통해서 sum 변수의 메모리 내용에는 index 변수의 값이 더해져 있게 된다.

- 변환 과정
  - C언어로 작성된 프로그램 → 컴파일 → 어셈블리어 → 기계어 코드 생성
- **C 컴파일러**: C 언어 프로그램에 표현된 의도대로 실행되도록 적절한 어셈블리 언어로 자동으로 변역한다.
- **어셈블러**: 이 프로그램을 기계어 코드로 번역해 준다.
  
![image](https://github.com/user-attachments/assets/3d7108b4-af23-4eab-8868-6ec8a03a8477)
- rrr로 표현된 부분: 레지스터 번호를 표현하는 부분
- 000으로 표현된 부분: AX 레지스터 표현
- 001으로 표현된 부분: BX 레지스터 표현
- aa...aa로 표현된 부분: 메모리 상의 주소를 나타낸다.

## 어셈블리 언어의 기초
![image](https://github.com/user-attachments/assets/cd5bc3b0-1233-48ab-8ffb-9cb19313ceed)

