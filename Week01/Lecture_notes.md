# 운영체제의 이해를 위한 기초(1장)
<img width="343" alt="image" src="https://github.com/user-attachments/assets/d1507900-c08a-49b3-b798-e9ff2db9746c" />

- Hardware는 CPU에 의해 실행된다.
- **인터럽트(Interrupt)**: CPU가 특정 기능을 수행하는 도중에 급하게 다른 일을 처리하고자 할 때 사용할 수 있는 기능
- **장치 드라이버(Device Driver)**: 컴퓨터에서 하드웨어 장치를 운영체제에 연결하기 위해 필요한 소프트웨어
- CPU가 어떤 일을 하고자 OS에게 인터럽트를 보내면 OS는 인터럽트를 수신하고 그에 대한 일을 수행한다.

<img width="349" alt="2" src="https://github.com/user-attachments/assets/b34de5cd-8eda-49ce-9066-de6dbded52ae" />

<img width="355" alt="3" src="https://github.com/user-attachments/assets/f35445e3-4168-480c-9698-c632ddf3384d" />

## 멀티태스킹 운영체제
- **여러 개의 프로세스들이 독립적으로 실행되도록 해주는 운영체제이다.**
- 운영체제에서는 여러 개의 작업 창을 띄어 놓고 이것저것 바꿔가면서 실행되도록 해준다.<br>
화면상에 나타나지 않으면서 내부적으로 실행되고 있는 작업들도 많은데, 이러한 작업들은 겉으로 보기에는 동시에 실행되고 있는 것처럼 보이지만,
이들은 실행하는 CPU는 하나 또는 다수이므로, 이들은 적절한 시간 간격으로 돌아가면서 실행된다.

- **프로세스(Process)**: 컴퓨터에서 실행되는 각 작업(임무)으로, 소프트웨어 그 자체라기 보다는 소프트웨어가 실행되어 메모리에 적재된 상태를 의미한다.(소프트웨어가 CPU에 의해 실행되어 메모리에 로드된 동적인 상태) 프로세스는 OS로부터 CPU시간, 메모리 영역, 파일 접근 권한 등을 할당받으며, 이 과정에서 각 프로세스는 고유한 ID와 실행 상태, 프로그램 카운터(PC), 레지스터 정보 등을 가진다.
- **소프트웨어(Software)**: 프로그램, 애플리케이션과 같이 코드와 데이터를 포함한 실행 가능한 파일로서, 디스크나 저장장치에 저장되어 있는 정적인 형태
- **멀티태스킹 운영체제(Multi-tasking OS)**: 여러 개의 프로세스들이 적절한 방법으로 돌아가면서 독립적으로 실행되도록 해주는 운영체제
- **스케줄링(Scheduling)**: 특정 시점에 여러 개의 프로세스들 중에서 실행할 대상으로 어떤 것을 선택하는 것
- **문맥교환(Context Switching)**: CPU가 현재 실행하던 프로세스를 보류하고, 스케줄링에 의해 선택된 프로세스를 실행하도록 변경하는 작업

## 컴퓨터를 사용한다는 것이란?
| 사용자가 원하는 응용 프로세스들을 실행시키고, 여기에 적절한 데이터를 키보드나 마우스 등의 입력장치로 입력하고, <br>
| 화면이나 종이, 파일 등의 출력 장치로 출력되는 내용을 얻는 과정
- 필요로 하는 응용 프로그램들을 실행시키는 것이 목적이다.
- **응용 프로그램(Application program)**: 적절한 입력에 대한 적절한 출력을 얻는 목적을 위해 만들어진 프로그램
## 운영체제를 사용한다는 것이란?
| 운영체제마다의 독특한 방법에 따라서 사용자가 원하는 프로그램 파일을 지정하여 프로세스로 생성되어 실행하도록 요청을 <br>
| 하고 이 프로세스는 실행되는 과정에서 운영체제의 각종 기능들을 적절히 호출하여 사용하는 것
- **운영체제 사용법**: 명령 해석기나 GUI에 사용자가 의도하는 작업을 표현하는 방법
- 명령 해석기(Command Interpreter)나 그래픽 사용자 인터페이스(Graphic User Interface) 프로세스가 실행되면서 사용자로부터 키보드나 마우스의 입력을 받아들이고, 이것의 의미에 따라 운영체제에게 적절한 작업을 진행하도록 한다.
- **UNIX의 명령 해석기's case**: 셸에서 실행할 파일 이름을 입력한 후 엔터키를 친다.
- **Windows's GUI case**: 원하는 아이콘이 있는 위치를 연달아 두 번 클릭함으로써 이 아이콘과 연결된 실행 파일이 실행되게 된다.

<img width="350" alt="4" src="https://github.com/user-attachments/assets/757184ab-9201-4e3d-b240-42408ec73fe4" />

- 사용자는 응용 프로세스들에 입력을 넣고, 출력을 얻는 과정을 통해 응용 프로세스들을 사용하고, 운영체제 상에서 실행되는 응용 프로세스들을 필요에 따라 운영체제의 기능들을 호출하여 사용하며(인터럽트), 운영체제는 필요에 따라 하드웨어 제어작업을 실행한다.
- 응용 프로세스들은 컴퓨터 하드웨어에 직접 접근하지 못하고 대신 운영체제에게 원하는 작업에 해당하는 기능을 호출하여 처리한다.
## 그렇다면, 왜 하드웨어는 운영체제를 통해서 접근을 할까? <br>응용 프로세스가 직접 접근하면 안되는건가?
- **프로그래머는 컴퓨터 하드웨어에 대한 세부적인 지식이 없어도 원하는 프로그램을 작성할 수 있게 된다.** <br>
컴퓨터마다 하드웨어의 구성이 다를 수 있고, 이를 제어하기 위해 복잡한 제어 방법을 숙지해야 한다. <br>
그러나, 운영체제에 하드웨어 관련된 기능들을 포함하도록 하고 표준적인 방법을 통해 응용 프로세스에게 하드웨어 제어 방법을 제공한다면 하드웨어의 종류에 상관없이 비교적 단순한 표준적인 방법으로 제어가 가능해진다.<br>또한, 장치 간의 차이로 인한 문제는 OS가 해결해준다.

- **응용 프로세스가 오류나 불법적인 의도에 의해 하드웨어를 잘못 조작함으로써 시스템 전체에 치명적인 영향을 주는 것을 방지할 수 있다.** <br>
운영체제는 응용 프로세스로부터 특정한 기능의 처리를 요청받으면 요청한 프로세스의 권한을 검사하여 권한을 가진 프로세스에 한해서 요청받은 기능을 실행해 주도록 한다.

<img width="352" alt="5" src="https://github.com/user-attachments/assets/0caccd23-680f-4018-a476-c249d698687d" />

- **컴퓨터를 사용하는 것**: 필요로 하는 응용 프로그램들을 실행하는 것이 목적이다.
- **응용 프로그램(Application program)**: 적절한 입력에 대한 적절한 출력을 얻는 목적을 위해 만들어진 프로그램
- **운영체제(Operating System)**: 다양한 응용 프로그램들을 효율적이면서도 편리하고 안전하게 실행할 수 있도록 지원해주는 프로그램<br>즉, 그 자체가 사용자가 원하는 작업이 아니라 그러한 작업들이 실행될 수 있도록 지원해 주는 프로그램이다.
- **펌웨어(Firmware)**: 특정 하드웨어 장치에 포함된 변하지 않는 소프트웨어
- **미들웨어(Middleware)**: 응용 프로세스 기능의 일부로, 여러 프로세서가 관련되어 있을 때, 공통적으로 사용할 수 있는 프로세스 <br>즉, 서로 다른 애플리케이션, 서비스, 운영체제 또는 하드웨어 간의 데이터 및 기능을 중개하는 소프트웨어이다.(OS에 속하지 않는다.)

## 운영체제를 사용하는 목적(이유)
![1](https://github.com/user-attachments/assets/22229807-690e-4e41-ad99-67ce62588e8c)
### 컴퓨터는 운영체제가 꼭 필요할까?
- 정답은 아니다!이다.(첫번째 사진)
- 컴퓨터가 개발되던 초창기의 컴퓨터에서는 OS가 없이  응용 프로그램 개발자가 하드웨어의 제어에 관련되는 부분들까지 모두 프로그램에 포함하여야 했다.
- 지금도 단순한 목적의 디지털 제어기들에는 단순한 CPU 및 극히 제한된 메모리만 사용되고, 실행 내용도 극히 제한된, 정해진 내용만 반복적으로 실행하는 경우에는 운영체제가 없이 구현되기도 한다.

### 운영체제와 미들웨어(Middel-ware)
- 어느 정도 성능의 CPU와 메모링 용량을 갖춘 시스템에서는 운영체제를 사용하면 여러 개의 응용 프로그램들이 멀티태스킹 방식으로 실행하도록 프로그램을 작성하는 것이 간편해진다.
- **미들웨어(Middle-ware)**: 시스템 관리자가 추가로 설치하여 사용자들에게 제공하는 소프트웨어로서, 운영체제에서는 제공하지 않지만 응용 프로그램들에서 필요로 하는 고도의 기능들을 제공한다.
- 응용 프로그램 개발자들은 미들웨어에서 제공하는 기능들을 활용함으로써 복잡한 응용 프로그램을 비교적 간편하게 개발할 수 있게 된다.
- 미들웨어 Example) 대규모 데이터베이스를 접근하는데 있어서 온라인 트랜잭션을 관리하는 소프트웨어(온라인 트랜잭션 부할를 적절히 분산시켜주고 상당 부분의 처리작업을 분담함으로써 데이터베이스 서버의 부하를 줄여준다.)

### 운영체제의 역할
- **컴퓨터를 사용하는 이유**: 사용자가 필요로 하는 응용프로그램들을 실행하기 위해서
- **응용프로그램을 실행하는 이유**: 적절한 입력에 대한 적절한 출력을 얻기 위해서
- **운영체제를 사용하는 이유**: CPU에 약간의 부가적인 오버헤드를 수반하거나, 운영체제를 사용함으로 인해 사용자에게 효율성, 편리성 및 안전성을 제공하기 위해서
  - **Hardware 자원의 효율적인 사용**: 멀티태스킹 및 스케줄링을 통해 CPU, 메모리, 입출력 장치 등의 자원을 프로세스들 간에 공유하여 효율적으로 활용하여 주어진 작업들을 빠른 시간 내에 처리할 수 있게 한다.<br> 예를 들어, 하나의 프로세스가 입출력 작업을 위해 대기하고 있는 동안에 CPU는 다른 프로세스를 실행함으로써 CPU를 놀리지 않고 효율적으로 사용할 수 있게 되며, 전체 메모리를 프로세스들 간에 적절히 나누어 사용할 수 있도록 한다. 또한, 디스크 공간에 많은 개수의 파일들을 효율적으로 배치하여 사용할 수 있게 해주고, 가상 메모리 기능을 통하여 물리적 메모리의 한계를 초과하여 많은 프로세스들을 실행할 수 있게 해준다.(디스크 입출력 성능을 높이기 위해 OS에서 필요한 기능을 제공한다.)
  - **컴퓨터 사용의 편리성 향상**: 응용 프로그램의 설치 및 실행 방법, 많은 수의 파일들의 접근 방법 등에 있어서 간편하게 명령어나 마우스 클릭으로 처리한다.
    - **컴퓨터 사용 과정에서의 편리성**: 명령 해석기를 제공함으로써 실행될 파일의 이름을 입력하는 것만으로 원하는 작업을 실행할 수 있다.(+ 그래픽 환경을 제공함으로써 관련 아이콘을 클릭하는 것만으로도 원하는 작업 실행 가능) 이외에도 파이프라인(Pipeline) 기능이나 입출력 리다이렉션 기능을 이용하여 입출력을 간단히 변경 할 수 있고, 실행 중인 프로세스들의 상태를 확인하고 필요에 따라 적절히 중지 시키거나, 강제로 종료시키거나, 우선적으로 실행하도록 제어할 수 있다. 또한, 디스크 상에 수많은 파일들을 기록하고, 원하는 파일을 검색하는 작업도 트리 형태의 논리적인 배치 체계 및 파일 검색기 등을 통하여 간편하게 처리할 수 있다.
    - **프로그램 개발 과정에서의 편리성**: 각 입출력 장치에 대한 구체적인 지식 없이도 입출력 작업에 대한 프로그램을 쉽게 작성할 수 있고, 디스크의 내부 구조 및 처리 방식에 대한 세부적인 고려 없이도 파일들의 생성, 읽기, 쓰기 및 삭제에 대한 프로그램을 작성할 수 있다. 또한, 메모리 활용에 대한 세부적인 고려 없이도 여러 프로그램들이 동시에 실행되도록 프로그램을 작성할 수 있다.(멀티태스킹 작성 가능)
  - **프로그램의 이식성 향상**: 하드웨어의 구성이 달라져도 실행 파일을 그대로 사용할 수 있거나, 컴파일만 다시 해주면 실행 가능하다.<br>동일한 프로그램을 전혀 다른 컴퓨터에서 그대로 사용할 수 있다. 동종의 하드웨어 동종의 운영체제일 경우에는 실행 파일을 그대로 사용할 수 있고, 이종의 하드웨어에 동종의 운영체제일 경우에는 다시 컴파일을하는 것만으로도 실행이 가능하다.<br>이종의 운영체제일 경우에는 운영체제에서 제공하는 기능이 서로 달라서 약간의 프로그램 수정이 필요할 수 있다.
  - **컴퓨터의 안전성 향상**: 프로그램의 오류나 바이러스 프로그램 등으로부터 컴퓨터 시스템을 보호한다.
    - 운영체제는 안전성 측면에서 프로세스들 간에 서로 보호되도록 하여 프로그램의 버그나 바이러스 프로그램이 다른 프로세스나 시스템 전체에 영향을 미치지 못하도록 한다.
  - **컴퓨터의 보안 강화**: 시스템을 부정사용으로부터 보호하기 위해 사용자 ID, Password, 프로세스 및 파일의 접근 권한 등을 활용한다.
    - 사용자들로부터 컴퓨터 시스템의 보안을 강화하기 위하여 프로세스를 사용자 별로 관리함으로써 다른 사용자의 프로세스를 임의로 방행할 수 없도록 하고, 파일들을 사용자별로 구분하여 보관하고 읽기나 쓰기, 실행 등을 사용자별로 제한할 수 있다.
    - 사용자 별로 고유 식별자와 암호를 통하여 시스템 사용 자체를 제한할 수 있다.


- 응용프로그램은 서로 다른 OS에서 Compile을 통해 사용할 수 있다.
- 파일 접근 권한(Read, Open, Write)은 개발자에 의해 처리될 수 있다.
 
- Bug(버그): 소프트웨어나 하드웨어가 예상된 대로 동작하지 않게 만드는 오류 또는 결함
- Virus(바이러스): 악성 소프트웨어(Malware)의 일종으로, 스스로 다른 정상적인 프로그램이나 파일에 삽입하여 복제하고 전파시키면서 컴퓨터의 정상적인 동작을 방해하거나 손상을 일으키는 프로그램(사용자의 동의 없이 다른 프로그램을 감염시키고 시스템의 데이터를 파괴하거나 기능을 마비시키는 악성 프로그램)
  - **바이러스의 특징**
  - 자가 복제(Self-Replication): 다른 프로그램이나 파일에 자신을 복사하여 전파한다.
  - 전파성(Propagation): 네트워크, USB, 이메일 첨부파일 등을 통해 쉽게 퍼져나간다.
  - 잠복성(Dormancy): 감염 후, 일정 시간이 지난 뒤 증상을 나타내기도 한다.
  - 파괴성(Destructive Behavior): 파일 삭제, 데이터 파괴, 시스템 불안정화 등 피해를 입힌다.

## 운영체제의 내부를 이해하면 어떻게 될까?
![2](https://github.com/user-attachments/assets/26b68f74-0d13-4eb2-a5e6-838fe7010957)
- **운영체제 개발 및 이식**: 새로운 컴퓨터 하드웨어나 휴대형 정보단말기 및 디지털 가전기기 등에 기존의 운영체제를 이식하기 위해서는 운영체제의 전반적인 지식을 바탕으로 하여 대상 하드웨어에 따라 운영체제를 부분적으로 수정할 필요가 있다.
- **컴퓨터 주변 장치 개발**: 컴퓨터 주변장치를 개발할 때, 이를 위한 장치 드라이버 프로그램을 운영체제에 맞게 개발해서 운영체제에 포함시켜 주어야 한다.
  - porting: 특정 OS나 SW를 새로운 하드웨어나 플랫폼으로 옮기는 작업(기존 OS를 새로운 장치에 이식하는 작업) 
- **고성능 응용 프로그램 개발**: 응용 프로그램을 개발하는 사람도 운영체제 내부의 지식을 활용하면, 보다 실행 속도가 빠른 프로그램의 개발이 가능하다.
  - 고속으로 실행하는 프로그램의 개발을 위해서는 적용한 알고리즘이 효율적인 것이어야 할 뿐만 아니라 운영체제 상에서 실행할 때 오버헤드가 적은 방법을 고려해야 할 필요가 있다.
  - 예를 들어, 동일한 실행 결과를 얻으면서도 가상메모리 기능의 페이지 폴트가 적게 나도록 하는 것을 고려하여 프로그램을 작성하면 운영체제의 오버헤드를 줄이고 실행속도를 높일 수 있게 된다.
  - 즉, RAM(Random Access Memory) 용량의 한계로 인해 가상 메모리가 작동하고, 그 과정에서 페이지 폴트가 발생하며, 이로 인해 디스크로부터 메모리를 가져오는 작업으로 성능이 저하된다.
    - **가상 메모리(Virtual Memmory)의 기본 원리**: 컴퓨터는 프로그램 실행 시, 필요한 데이터를 RAM(주 메모리)에 올려두고 작업한다. 하지만, 여러 프로그램이 동시에 실행되거나 큰 프로그램을 사용할 경우 RAM 용량이 부족할 수 있다. 이때, 컴퓨터는 가상 메모리라는 기술을 사용하여 부족한 RAM 용량을 디스크 공간(보조기억장치)으로 보충한다.<br>즉, 물리적 RAM 공간을 넘어서는 더 큰 논리적 공간을 만드는 기술이 바로 가상 메모리이다.
    - **페이지 폴트(Page Fault)**: 운영체제는 가상 메모리를 일정한 단위(보통, 4KB)로 나누어 관리하는데, 이 단위를 **페이지(Page)**라고 한다.<br>**페이지(Page)**는 프로그램의 데이터와 코드가 저장되는 메모리의 작은 조각이다. 페이지 폴트는 CPU가 필요한 페이지가 현재 RAM에 없을 때 발생한다.<br>즉, 프로그램이 RAM 용량보다 큰 메모리를 요구하거나 동시에 많은 프로그램이 실행될 때, RAM이 부족할 때, 필요한 데이터가 RAM에서 디스크로 밀려났다가 다시 요청될 때 발생되고, 빈번하게 페이지 폴트가 발생하면 지속적인 디스크 접근으로 성능 저하가 심각해지고, 결국 시스템의 전체적인 속도가 떨어지게 된다.
    - **페이지 폴트 발생 시, 운영체제 작업**:<br>
      1. CPU가 특정 페이지를 요구<br>
      2. 해당 페이지가 현재 RAM에 없을 경우, 페이지 폴트 발생<br>
      3. 운영체제는 디스크(가상 메모리)에 저장된 페이지를 찾아 RAM으로 로드<br>
      4. RAM에 공간이 부족하면 이미 메모리에 있던 페이지를 디스크에 다시 내려놓는다.(페이지 교체)<br>
      5. 페이지 로딩이 완료되면 다시 프로그램 실행<br>
      → 이 과정에서 디스크 접근 속도는 RAM보다 매우 느리므로, 지연이 발생하게 된다.
- **컴퓨터 시스템 관리**: 컴퓨터 시스템 관리자는 운영체제의 특성을 잘 파악하여 시스템이 최상의 성능을 유지하도록 관리해야 한다.<br>예를 들어, 커널 및 시스템 설정 파라미터들을 적절히 조정해 주어야 하고 주기적으로 파일 시스템을 점검하고 백업 작업을 해야 한다. 또한, 시스템 관리자는 사용자별 계정의 관리 및 사용자별 사용 자원의 상한선 설정, 적절한 암호화와 보호 모드 설정, 네트워크 접속 관련 구성 설정 등의 작업도 해주어야 한다.

## 운영체제의 구성
![3](https://github.com/user-attachments/assets/d384f6d0-be4b-4b62-bd31-58beaf3141d0)
### 운영체제의 핵심 구성요소
- 프로세스 관리
- 메모리 관리
- 파일 관리
### 시스템 콜 함수(System Call)
- 운영체제가 제공하는 함수로, 프로그램(사용자 모드)이 운영체제(커널 모드)의 기능을 이용할 때, 호출하는 특수한 인터페이스이다.
- 즉, 프로그램이 운영체제가 관리하는 자원(하드웨어, 파일 시스템, 네트워크 등)에 접근하고 싶을 때, 사용하는 함수이다.
- **왜 필요한가?**
  - 프로그램은 일반적으로 사용자 모드에서 동작한다.
  - 하드웨어나 시스템 자원을 직접 제어하는 것은 커널 모드에서만 가능하다.(사용자는 직접 제어할 수 없고, OS에서만이 중요 자원을 직접 제어할 수 있다.)
  - 사용자 프로그램이 하드웨어에 접근하려면 반드시 커널 모드로 전환한 후, 운영체제의 도움을 받아야 한다.
  - 이때, 프로그램이 운영체제에게 요청하는 인터페이스가 바로 **시스템 콜 함수**이다
- **시스템 콜의 작동 원리**
  프로세스가 시스템 콜을 호출하면:
  1. 프로그램이 시스템 콜을 호출하여 커널(좁은 의미의 OS)에게 특정 작업 요청
  2. CPU가 사용자 모드에서 커널 모드로 전환(보호 모드 전환)
  3. 커널이 요청된 작업 수행(파일 읽기/쓰기, 메모리 할당 등)
  4. 작업 완료 후, 결과를 사용자 프로그램에 반환
  5. 커널 모드에서 다시 사용자 모드로 복귀하여 프로그램 계속 실  
### 프로세스 관리(Process Management)
- 프로그램들을 실행하는 과정에서 프로세스의 생성(Create), 삭제(Delete), 실행 중지(Suspend), 실행 재개(Resume) 등을 통하여 프로세스들을 관리한다.
- 스케줄링을 통하여 CPU의 활용률을 높이고 프로세스들 간에 공평한 실행 기회를 부여하는 방향으로 프로세스들의 실행 순서를 적절히 결정한다.
- 여기에는 여러 프로세스들이 실행되는 과정에서 적절히 보조를 맞추어서 진행되도록 처리하는 프로세스 동기화(Synchronization) 기능과 프로세스 간에 정보를 교환할 수 있는 통신(Interprocess Communication) 기능 등도 포함된다.
### 메모리 관리(Memory Management)
- 전체 메모리 중에서 비어 있는 영역 및 프로세스 별로 사용 중인 메모리 영역을 기록하여 관리하고, 이 정보를 바탕으로 하여 프로세스들을 위해 메모리 영역을 할당하거나 할당된 영역을 회수한다.
- 가상 메모리 기능을 제공할 경우에는 프로세스 별로 페이지들을 위해 메모리 프레임들을 적절히 할당하고 당장의 실행에 필요하지 않은 부분들을 선택하여 스왑 디바이스에 기록하는 작업도 수행한다.
  - **스왑 디바이스(Swap Device)**
    - 운영체제가 여러 프로그램을 실행하다 RAM이 부족해지면, 자주 사용하지 않는 데이터를 잠시 디스크에 내려놓는다.(페이지 폴트) 이렇게 디스크로 내려놓는 공간이 바로 스왑 디바이스이다.
    - RAM의 연장으로 활용되고, 가상 메모리 환경에서 페이지 교체 작업에 사용되며 실제 메모리의 크기보다 더 큰 프로그램을 실행할 수 있게 지원한다.
    - RAM 용량 부족 시, 시스템이 멈추거나 프로그램이 강제로 종료되는 것을 방지하고, 큰 프로그램이나 다수의 프로그램을 동시 실행할 수 있게 보조 역할을 한다.   
- 한정된 크기의 메모리를 효율적으로 활용할 수 있는 방향으로 여러 프로세스들에 메모리를 할당해 주거나 회수한다.
### 파일 관리(File Management)
- 전체 디스크 영역을 나누어서 파일들을 위해 일정한 영억을 할당하거나 할당된 영역을 회수한다.
- 이를 위해 파일별로 사용 중인 디스크 영역과 비어 있는 영역에 대한 정보를 기록하여 관리한다.
- 파일의 생성(Create), 삭제(Delete 또는 Seek), 등의 기능을 제공하며, 파일들을 디렉터리 별로 관리할 수 있는 기능도 제공한다.
- 전체 디스크 공간을 수많은 파일들에게 할당해 주거나 회수하는 과정에서 파일의 찾기, 읽기, 쓰기, 크기확장 등의 작업을 효율적으로 처리할 수 있도록 한다.
- **파일 공유**: 장치에는 없지만 다른 컴퓨터에서 존재하는 파일을 사용할 수 있다.
### 입출력 장치 관리(I/O Device Management)
- 컴퓨터 시스템에 장착된 입출력 장치들을 제어할 수 있는 디바이스 드라이버(Device Driver) 루틴들을 가지고 있어서 프로세스들이 입출력 작업을 요청하면 적절한 드라이버 루틴을 실행한다.
- 입출력 장치들에 대한 작업 요구는 표준화된 방식으로 처리할 수 있도록 한다.
- 대부분의 OS에서는 open, close, read, write, lseek 등의 표준 함수를 제공한다.
- 디스크의 경우에는 입출력 성능을 높이기 위해서 디스크 스케줄링, 디스크 캐시, 지연 기록 등의 기능도 제공한다.
### 시스템 보호 및 보안(Protection and Security)
- 프로세스(사용자)들이 시스템 자원이나 사용자 자원들(파일, 메모리, 데이터, 입출력 장치 등)을 접근(읽기, 쓰기, 생성, 삭제 등)하는 것을 적절한 방법으로 제한함으로써 시스템을 안전하게 보호하고 프로세스 간에 잘못된 영향을 미치지 않도록 한다.
- 프로세스들이 시스템의 중요한 정보를 읽거나 변경하는 것을 제한하고, 다른 프로세스의 메모리 영역을 침범하지 못하도록 처리하며, 사용자들 간에 허가되지 않은 파일의 내용을 읽거나 변경하지 못하도록 하고, 다른 사람이 실행 중인 프로세스들에 영향을 미치지 못하도록 처리하는 등의 기능이 여기에 포함된다.
- 시스템의 보안을 위해서 허가받지 않은 사람의 접근을 제한할 수 있도록 컴퓨터에 접속하는 과정에서 사용자 식별자와 패스워드를 적용하고, 네트워크를 통해 접속되는 권한을 적절히 제한한다.
### 분산처리(Distibuted Processing)
- 분산처리 기능은 네트워크를 통하여 연결된 단위 컴퓨터 시스템들의 집합을 사용자 입장에서 하나의 시스템처럼 사용할 수 있게 해준다.
- 이를 위해서는 단위 시스템들 간에 파일이나 장치들을 공유하여 자체 시스템에 장착된 것처럼 사용할 수 있는 기능을 제공한다.
- 예를 들어, 네트워크 파일 시스템이나 Windows의 파일 공유 기능 등이 있다. 더 나아가서는 프로세스들을 단위 시스템들 간에 적절히 분담하여 처리할 수 있는 기능을 제공한다.
- 사용자에게는 특정 단위 시스템에 대한 구별 없이 단위 시스템들의 집합 전체 중의 일부를 사용할 수 있도록 처리해 준다.
### 명령 해석기(Command Interpreter)
- 사용자가 원하는 작업을 지정할 수 있는 수단을 제공해 주는 기능
- 사용자로부터 특정 작업을 표시하는 입력을 받아들여서 운영체제에 해당 작업 실행해 주도록 요청하는 기능을 수행한다.
- 최근의 OS들에서는 일반적으로 명령 해석기가 커널의 구성 요소가 아니라 별도의 프로세스로 실행된다.
- UNIX의 셸이 이것에 해당되며, 그래픽 환경을 제공하는 경우에는 화면에 아이콘들을 표시하고, 마우스 입력을 받아서 적절하게 프로세스들을 실행하도록 처리하는 프로세스가 이것에 해당한다. 

## 운영체제 모듈간의 호출관계
![image](https://github.com/user-attachments/assets/2c7fdb87-2bc1-45c8-b9b4-171b8c1a399f)

## 모놀리식 커널 & 마이크로 커널
![image](https://github.com/user-attachments/assets/a563aae0-5a2e-4685-9b3a-d3a3f01148f2)
### 모놀리식 커널(Monolithic Kernel)
- 운영체제의 모든 핵심 기능(메모리 관리, 파일 시스템, 디바이스 드라이버, 프로세스 관리 등)이 하나의 큰 커널 안에 포함되어 있는 구조이다.
- 전통적인 운영체제의 구현 방법으로, 운영체제의 모든 기능들을 묶어서 하나의 커널 파일을 구성하고 이것을 부팅 과정에서 메모리에 적재하여 실행하는 방식이다.
- 커널 파일은 필요한 모든 함수들을 내부에 포함하고 있다.(리눅스는 여전히 모놀로식 커널방식을 사용하고 있다.)
- 프로세스 요청 시, OS 기능 즉시 실행!
  - **특징**:
    - 모든 OS 기능이 커널 내에서 직접 처리
    - 성능이 뛰어남(모듈 간 통신 비용 낮음)
    - 구조가 복잡하고, 버그 하나가 전체 시스템에 영향을 줄 수 있다.(안전성이 떨어질 수 있다.)
    - 기능을 추가하거나 수정할 때, 커널 전체를 다시 컴파일하거나 재부팅이 필요하다.
### 마이크로 커널(Micro Kernel)
- 커널에는 기본적인 기능만 포함시키고 대부분의 운영체제 기능은 별도의 서버 프로세스들로 구현한다.
- 프로세스가 운영체제에 필요한 기능을 호출하기 위해서는 서버 프로세스에게 작업 내용을 메시지 형태로 작성하여 전달하고, 서버 프로세스는 작업 결과를 다시 메시지 형태로 작성하여 반환한다.
- 운영체제의 기능이 프로세스 단위로 되어 있으므로 하나의 서버 프로세스에 문제가 발생하더라도 운영체제의 다른 기능은 영향을 받지 않으며, 실행 중에도 운영체제의 기능들을 간편하게 변경할 수 있다.
- 새로운 하드웨어에 이식 작업(Porting)을 하는 데에도 작은 크기의 커널 부분만 처리하면 되므로 작업이 비교적 수월해진다.
- 반면에, 모든 처리가 프로세스 간의 메시지 통신으로 이루어지기 때문에 속도가 느려진다.
- 실제로 Windows는 마이크로 커널 구조를 지향했다가 속도 저하 문제로 인해 서버 프로세스들의 상당 부분을 다시 커널 내부의 모듈로 전환한 하이브리드 형태를 취하고 있다.
- Mach 기반 운영체제나 Windows 등이 이 방식에 바탕을 두고 있다.
- **특징**:
  - 커널 크기가 작고 단순하다.
  - 장애 발생 시 전체 시스템을 멈추지 않고, 문제가 발생한 프로세스만 재시작 가능하다.
  - 모듈별로 독립된 개발 및 유지 보수가 가능하다.(모듈화로 인해 안정성 및 확장성이 뛰어남)
  - 프로세스 간 메시지 전달(IPC, Inter-Process Communication)로 동작해서 다소 성능 저하가 발생할 수 있다.(모놀로식 커널방식에 비해 상대적으로 느림)
  
![image](https://github.com/user-attachments/assets/d941a101-c4c3-4ec6-aeb8-27e00c23fe4a)

### 계층적 구조
- 계층적(Layered) 구조는 커널 부분의 기능을 계층적으로 세분화하고 각 계층은 바로 위의 계층에서만 호출될 수 있게 한다.
- 계층적 구조는 소프트웨어 공학 관점에서의 효율성을 위한 것으로 복잡한 커널을 개발하고 기능을 변경 및 확장해 나가는 작업을 체계적이고도 효율적으로 할 수 있도록 해 준다.
- 반면, 몇 단계 아래의 하위 계층의 기능을 호출하기 위해서는 여러 계층을 거치므로 전체적인 성능이 저하될 수 있다.
- 따라서, 계층적 구조도 마이크로 커널 구조와 마찬가지로 소프트웨어 공학적인 관점에서의 장점이 있는 반면에 실행 속도 면에서는 불리하므로 실제 운영체제에서는 부분적으로만 활용하고 있다.

### 모듈(Modular) 구조
- 소프트웨어 또는 운영체제를 구성하는 기능이나 컴포넌트를 각각 독립적인 모듈로 나누어 설계한 구조이다.
  - **모듈(Module)**:
    - 프로그램이나 소프트웨어의 일부로서, 독립적으로 기능을 수행할 수 있는 작은 단위
    - 각 모듈은 명확인 정의된 인터페이스를 통해 서로 상호작용한다.
    - 서로 결합하거나 교체하기 쉬운 구조로 설계된다.
    - 유지보수가 용이하다.(이로 인해 확장성이 좋다.)
    - 안정성 및 신뢰성이 높다.
    - 재사용이 가능하다.
    - 병렬 개발에 용이하다.
    
- 계층적으로 세분화하거나 서버 프로세스로 분리하지 않고도, 소프트웨어 공학적인 효율성을 얻기 위해 객체지향의 개념을 도입한 것이다.
- 커널의 기능을 모듈별로 세분화하여 모듈별 변경이나 모듈의 추가 및 삭제가 쉽도록 한다.
- 리눅스에서는 모놀리식 구조를 유지하면서도 모듈 구조 개념을 도입하여 각 기능을 모듈별로 분리하였으며, 실행 중에도 커널의 모듈을 추가하거나 삭제할 수 있는 기능을 제공함으로써 커널의 기능을 실행 중에 비교적 용이하게 변경할 수 있다.

## 응용 프로그램의 작성 및 실행
- 컴퓨터 상에서 특정 응용 프로그램이 실행되기 위해서는 우선 기계어 코드로 된 실행 프로그램 파일을 생성하는 방법이 제공되어야 하고, 실행 프로그램 파일을 메모리에 적재하여 실행하는 방법이 제공되어야 한다.
- 또한, 실행이 종료된 이후에 사용하던 메모리 등의 자원들을 다른 프로그램이 실행될 때 재사용될 수 있도록 적절한 관리 작업이 이루어져야 한다.
### 실행 파일 생성 방식
- **자체 컴파일러(Native Compiler)**:
  - 개발하는 프로그램이 실행될 컴퓨터에서 프로그램을 편집하여 컴파일하는 방식
- **크로스 컴파일러(Cross Compiler)**:
  - 프로그램 개발을 위한 별도의 컴퓨터(호스트)에서 편집 및 컴파일 작업을 완료하고, 완성된 실행파일을 실제 실행될 컴퓨터로 옮겨서 실행하는 방식
→ 이 과정에서 프로그래머는 실행될 컴퓨터의 운영체제에 따라 그 운영체제가 제공하는 함수들을 적절히 활용하여 프로그램을 작성해야 한다.
### 프로그램 적재 방법
1. 디스크(또는 플래시 메모리)에 파일 형태로 저장해 두고 이것을 필요한 시점에 운영체제의 기능을 활용하여 메모리에 적재하는 방법
2. ROM에 기록하여 전원을 켜면 프로그램이 바로 실행될 수 있도록 하는 방법
   - **ROM(Read-Only Memory, 읽기 전용 메모리)**:
     - 데이터를 읽기만 가능하고, 쓰기는 불가능하거나 제한된 메모리
     - 주로 하드웨어 장치의 펌웨어를 저장할 때 사용된다.
     - 비휘발성: 전원을 꺼도 데이터가 유지된다.
     - 읽기 전용: 데이터를 읽기만 가능하고, 쓰기는 제한된다.
     - 영구 저장: 전원이 없는 상태에서도 데이터가 유지된다.
     - RAM에 비해 상대적으로 느리다.
3. 직렬 포트나 통신망을 통하여 호스트 컴퓨터에서 받아와서 메모리에 적재하고 실행하는 방법(자체 디스크 없이도 여러 가지 프로그램들을 실행시킬 수 있다.)
### 프로그램의 실행 시작
- 메모리에 적재된 프로그램은 운영체제에 의해 프로세서의 PC(Program Counter, 또는 IP:Instruction Pointer) 레지스터의 값을 적재된 프로그램의 시작 주소로 변경함으로써 이 프로그램의 실행이 시작된다.
- 프로그램이 종료되면 운영체제는 그 프로그램이 사용하던 메모리와 입출력 장치를 포함한 자원들을 다른 프로그램이 실행될 때 다시 사용할 수 있도록 목록을 관리한다.

## 명령 해석기
![image](https://github.com/user-attachments/assets/3d0da091-a3da-4fa7-a8c4-b7beb5bb34c4)
- 프로그램을 실행시키기 위해서는 운영체제에서 제공하는 특정 함수를 이용한다.
- 이 함수에는 실행될 프로그램의 파일 이름을 인수로 지정한다.
- 즉, 사용자로부터 실행 내용에 관한 입력을 받아들이고 여기에 표현된 원하는 프로그램 파일을 찾아서 이 이름을 인수로 사용하여 운영체제의 프로그램 실행을 요청하는 함수를 호출한다.
- 일반적으로, 명령 해석기는 먼저 사용자에게 명령 입력을 기다린다는 표시로서 프롬프트를 화면에 보여주고 엔터 키가 입력될 때까지의 한 줄을 읽어 들인 다음, 첫 번째 단어를 실행될 프로그램의 파일 이름으로 지정하여 실행을 요청한다.
- 명령 해석기도 운영체제 상에서 실행되는 프로그램들 중의 하나이며, 사용자의 로그인 과정에서 생성되고 로그아웃 과정에서 종료되어 없어진다.
- CUI vs GUI:
  - 명령을 입력하는 방식이 명령어를 입력하거나 화면의 아이콘을 클릭하는 방식에서 차이가 있다.
  - GUI는 아이콘을 클락하고 이 아이콘에 연결된 파일을 실행할 프로그램 파일로 결정하는 과정이 CUI와 차이가 있다.
### UNIX에서 사용자는 로그인 절차를 거친 후에 셸을 통해 원하는 프로그램의 실행을 처리할 수 있다.(UNIX Shell 동작 과정)
1. (셸) (프롬프트 출력)
2. (사용자) (명령과 엔터 키 입력)
3. (셸) (fork 및 exec 시스템 콜 함수)
4. (운영체제)
5. (응용 프로그램) (exit 시스템 콜 함수)
6. (운영체제)
7. (셸) 반복

![image](https://github.com/user-attachments/assets/880a8bb4-07f3-401d-a11b-2d3126b4af94)
- printf("Shell> "); : (1)프롬프트 출력
- scanf("%s", command); : (3)명령 입력
- if(! strcmp(command, "exit")) exit(0); : "exit"명령이면 셸 종료
- childpid = fork(); : (3)자식 프로세스 생성 요청
- if(childpid == 0){~~} : 자식 프로세스는 (3)지정된 파일 실행 요청 및 실행 실패 메시지 출력, 스스로 종료 요청
- wait(&exitcode); : (7)자식 프로세스가 종료될 때까지 대기 및 다음 명령을 위해 (1)부터 작업 반복
### Background로 작동 시, 장점
- Shell1이 실행 중일 때, Shell2 명령어를 동시에 받아 처리할 수 있다.
- fork(): 프로세스 생성
- Child 끝나면 wait에서 멈췄던 작업을 실행한다.
  
## 일반적인 부팅 과정
- 컴퓨터를 사용하기 위해 전원을 켜는 시점부터 명령 해석기가 실행되어서 사용자가 원하는 프로그램을 실행할 수 있도록 되는 과정
![image](https://github.com/user-attachments/assets/b93abd15-9b64-4905-b1c3-8ee2154e06d8)
1. 전원을 켜면 ROM의 프로그램이 작동하며, 여기서 메모리 크기나 입출력 장치 등의 하드웨어 검사를 실시한 후, 처음으로 발견된 디스크(부트 디스크, Boot Disk)의 첫번째 블록(부트 블록, Boot Block)에 있는 프로그램(부트 로더, Boot Loader)을 읽어서 메모리의 지정된 주소에 적재한 후 이것을 실행한다.
2. 부트 로더는 실행될 운영체제 파일을 부트 디스크에서 찾아서 메모리의 지정된 주소에 적재한 후 이것을 실행한다. 이 과정에서 실행될 운영체제의 파일명을 키보드로부터 읽어 들여서 사용하기도 한다.
3. 운영체제 커널은 각종 변수들 및 입출력 장치들을 초기화한 후 명령 해석기를 실행시킨다.<br>UNIX와 같은 멀티유저 시스템인 경우, 명령 해석기 대신 로그인 절차를 담당하는 프로세스를 여러 개 생성하여 실행시키는데, 이 프로세스는 사용자의 식별자와 패스워드를 읽어 들여서 확인 절차를 거친 후 명령 해석기 프로세스로 전환된다.
4. 명령 해석기는 프롬프트를 출력한 후, 사용자로부터 명령을 읽어 들이고, 운영체제 커널에 이 명령에 해당하는 프로그램 파일로 새로운 프로세스를 생성하여 실행시키도록 요청한다.
### 커널이란?
- 좁은 의미: 메모리에 적재되어 항상 실행되는 프로그램(운영체제 부분)
- 넓은 의미: 좁은 의미의 커널과 명령 해석기를 포함한 각종 유틸리티 프로그램들을 포함한다(Ex. Linux, Windows)
- 커널은 전원을 끌 때까지 메모리에 상주하면서 언제든지 실행 가능 상태로 유지된다.
- 일반적으로 커널 부분은 디스크에 파일 형태로 존재하며, 부트 로더가 이것을 찾아서 메모리의 지정되 주소 영역에 적재한다.

## 기본적인 용어 정의
![image](https://github.com/user-attachments/assets/db3908b0-1b87-4c51-bb29-e2b49882813b)
![image](https://github.com/user-attachments/assets/72e42143-764e-483d-aba5-0ba301e8518d)

