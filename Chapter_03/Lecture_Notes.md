# 프로세스 관리
## 이해하고 넘어가야 할 내용
- 문맥교환의 의미 및 이를 위해 처리할 내용
- CPU가 운영체제 부분과 프로세스들 간에 이동해 가면서 실행하는 과정
- 프로세스/스레드의 의미 및 이들의 연관성
- 프로세스/스레드 제어블록이 필요한 이유 및 여기에 기록 해야 할 정보
- 스케줄링과 문맥교환의 실제 구현 방법
- 프로세스/스레드의 생성 및 삭제 과정에서 해야할 일들과 이를 구현하는 방법

![image](https://github.com/user-attachments/assets/6975cc50-7e1b-43dd-8738-5bb6fb2aa31f)
## 프로세스(Process)
- 지정된 프로그램에 표현된 내용대로 실제 실행을 하는 능동적인 개체이다.
- 프로그램이 실제 실행되고 있는 상태의 능동적인 개체로, 운영체제의 스케줄링 및 관리 단위이다.
![image](https://github.com/user-attachments/assets/30f17286-4bf3-46ce-800f-ebb207618752)
### 사용자가 실행 프로그램을 사용하려고 했을 때의 과정
1. 컴퓨터 사용자는 명령해석기의 도움으로 미리 작성된 실행 가능 프로그램을 실행하도록 운영체제에게 요청한다.
2. 운영체제는 새로운 프로세스를 생성하고, 이 프로세스가 실행할 작업 내용으로서 지정한 프로그램이 사용되도록 한다.
3. 운영체제는 많은 개수의 프로세스들을 대상으로 적절히 스케줄링 및 문맥교환 처리를 한다.

### 프로세스 생성 요청
- 사용자가 셸 프로세스에게 실행해야할 파일을 지정하여 실행하도록 입력을 하면, 셸 프로세스는 운영체제에게 파일명을 지정하여 프로세스를 생성하는 시스템 콜 함수를 호출한다.
- 물론, 셸이 아닌 임의의 프로세스에서도 프로세스를 생성하는 시스템 콜 함수를 통하여 프로세스들을 생성할 수 있다.
### 프로세스 간의 관계
![image](https://github.com/user-attachments/assets/a13fe258-9e11-458d-9946-a9a9a574793f)
- **자식 프로세스(Child Process)**: 새로운 프로세스가 시스템 콜 함수를 통하여 운영체제에 의해 생성되면 생성된 프로세스
- **부모 프로세스(Parent Process)**: 생성을 요청한 프로세스
- 운영체제에서 실행되고 있는 모든 프로세스들은 서로 간에 부모-자식의 관계를 이루고 있는 하나의 계보를 형성하고, 최상위에는 운영체제가 부팅되어 실행을 시작할 때 생성된 최초의 프로세스가 위치한다.
### 프로세스 종료 요청
- 각 프로세스는 프로그램에 표현된 수행해야 할 작업을 완료하면 최종적으로 종료되어 없어진다.
- 종료되는 과정은 실행 중인 프로세스 자신이 스스로 운영체제에 프로세스 종료를 위한 시스템 콜 함수를 호출하여 이루어진다. (+ 다른 프로세스를 강제로 종료시키도록 운영체제에게 요청하는 시스템 콜 함수도 있다.)

## 메모리 상의 프로세스 구성 및 실행
![image](https://github.com/user-attachments/assets/1d9191eb-af40-49eb-865f-be70310add6a)
- 프로세스가 실행되기 위해서는 일정한 메모리 영역을 확보하고 여기에 프로세스가 실행해야 할 내용들이 기록되어 있어야 한다.
### 하나의 프로세스가 차지하고 있는 메모리 영역
- **코드 영역**: CPU가 실행해야 할 내용을 기계어 코드로 표현하는 영역
- **데이터 영역**: 각종 전역변수나 실행 중에 메모리 할당 요청을 통해 할당받은 메모리 등을 포함하는 영역
- **스택 영역**: 함수의 호출 과정에서 파라미터 전달이나 함수속의 지역변수들을 저장하는 영역

## 실행파일의 적재
![image](https://github.com/user-attachments/assets/f818fe3c-ecd5-425d-91b0-6111cb217b5a)
- 파일 헤더 부분에는 파일의 기록 형식, 코드 섹션과 데이터 섹션의 파일 내의 위치와 크기 정보 등을 포함한다.
- 운영체제는 프로세스를 생성하는 과정에서 지정된 실행 프로그램 파일의 헤더 부분을 읽어서 필요한 메모리 용량을 결정하고 그만큼의 메모리를 확보한 다음, 파일의 코드 섹션 부분 내용을 읽어 들여서 코드 영역에 기록한다.
- 프로그램 파일의 데이터 섹션 부분을 읽어 들여서 데이터 영억에 기록한다.
- 스택 영역은 그냥 메모리만 확보해 두고 스택의 바닥부분부터 시작하여 사용하도록 한다.
- 스택에는 함수의 호출과 반환 과정에서 적절한 내용들이 쌓였다가 제거되는 과정을 반복한다.

## 유닉스의 프로세스 생성
![image](https://github.com/user-attachments/assets/ca66dd12-7bb7-44c0-b28c-1ee7f09484c7)
![image](https://github.com/user-attachments/assets/5b0b45ff-0c4d-40d1-9a1b-8e478b66a3de)
- 유닉스에서는 fork() 시스템 콜에 의해서 새로운 프로세스가 생성된다.(호출한 프로세스와 실행 내용이 동일하다.)
### UNIX Exec 시스템 콜 함수의 처리 과정
![image](https://github.com/user-attachments/assets/e4e773ba-98c6-4468-a17d-ee82d540484b)
- 프로세스가 생성되고, exec() 시스템 콜에 의해서 실행 내용을 다른 프로그램으로 변경한다.
- 프로그램 파일 이름을 인수로 하여 exec()를 호출하면 운영체제는 호출한 프로세스의 현재 메모리 내용을 전부 삭제한 후에 지정된 프로그램 파일의 내용을 메모리에 적재하고, 이 프로세스는 프로그램의 처음부터 실행을 시작하게 된다.
- 운영체제는 프로그램을 메모리에 적재할 때 먼저 프로그램 파일의 헤더 부분을 읽어서 코드 섹션의 크기, 데이터 섹션의 크기, 실행 시작 주소 등을 확인한다.
- 코드 섹션의 크기만큼의 메모리를 할당하고, 여기에 코드 섹션을 읽어 들이도록 디스크 제어기에 명령을 전달한다.(데이터 섹션도 동일한 과정을 거친다.)
- 스택은 표준 크기의 메모리를 할당하고 그 바닥에 해당하는 메모리 주소를 스택 포인터 레지스터의 값이 되도록 설정한다.
- 헤더에서 확인한 실행 시작 주소는 프로그램 카운터(PC 또는 IP)의 값이 되도록 설정한다.
- 이후에 이 프로세스가 선택되어 실행을 하게 되면 시작주소부터 명령어들을 실행하게 된다.
### OS별 프로세스 목록 참고
![image](https://github.com/user-attachments/assets/3a4673df-cc03-4f43-9a8e-33c8ccc5fa7d)
![image](https://github.com/user-attachments/assets/719869ec-a721-49be-a333-77d5c9639302)

## 간단한 프로세스 상태천이도
![image](https://github.com/user-attachments/assets/4c2b702e-53f1-43af-ad31-88bd1a9a4346)
- 하나의 프로세스는 생성된 후에 프로그램에 표현된 내용대로 실행되고 최종적으로는 종료되어 소멸되는데, 이 과정에서 여러 가지 상태들을 거치게 된다.
- 예를 들면, 프로세스가 특정 파일에 대하여 읽기를 위한 시스템 콜 함수를 호출하면 운영체제는 디스크 제어기에게 읽기를 위한 명령을 전달한다.
그런데, 디스크로부터 읽기 작업은 일정한 시간이 소요되므로 이 시간 동안 CPU가 다른 프로세스를 선택하여 실행하도록 하는 것이 필요하다.
- 이렇게 디스크 읽기 작업이 완료될 때까지 기다리는 프로세스는 스케줄링 과정에서 선택 대상에서 제외되도록 해야 한다.
  
### 동작 과정
- 프로세스가 생성되면, Ready 상태로 설정되고, 이후에 스케줄러에 의해 선택되면 Running 상태로 전환되어 실행된다.
- 실행되는 도중에 입출력 작업을 요청하거나 일정한 조건이 만족될 때까지 기다려야 하는 경우에는 조건이 만족될 때까지 Waiting 상태로 전환된다.
- 일정한 시간이 지난 후에 요청한 조건이 모두 만족되면 이 프로세스는 Ready 상태로 전환되고 이후에 스케줄러에 의해 다시 선택될 수 있게 된다.
- 실행을 완료하게 되면 종료 절차에 의해서 프로세스는 소멸된다.
    
### ● → ▲이 되는 경우
- **Running → Waiting → Ready**
  - 파일 읽기를 요청하면, Waiting 상태로 변경하는데 디스크 제어기에 의해서 그 작업이 완료되는 시점에 다시 Ready 상태로 변경한다.
  - 키보드와 같은 입력 장치에 입력을 요청하면 실제 입력이 될 때까지 Waiting 상태로 유지한다.
  - 이 외에도 일정한 시간동안 기다렸다가 실행을 계속하도록 요청하는 경우, 자식 프로세스가 종료될 때까지 대기하도록 요청하는(wait 시스템 콜) 경우, 다른 프로세스로부터 메시지 수신을 대기하는 경우, 프로세스 간의 동기화를 위해서 특정 조건이 만족될 때까지 대기하는 경우 등 다양하다.

### 스케줄링
- 많은 프로세스들 중에서 Running 상태의 프로세스는 현재 실행 중인 프로세스로서 오직 하나만 존재하고 Ready 상태나 Waiting 상태의 프로세스들은 여러 개가 동시에 존재할 수 있다.
- 스케줄러는 Ready 상태의 프로세스들 중에서 정해진 원칙에 따라 하나를 선택한다.
- 스케줄러는 운영체제의 일부로 존재하는 함수로서 스케줄링이 필요할 때마다 호출되는데 프로세스들의 상태가 변경되는 시점들과 실행 중인 프로세스에게 할당된 시간이 만료되었을 때 등이 스케줄링이 필요한 시점이다.
- 스케줄링 함수에 의해 선택된 프로세스가 직전에 실행되던 프로세스와 다르면 문맥교환 함수를 통하여 선택된 프로세스로 변경하여 실행하도록 처리한다.

### 선점
- 현재 Running 상태의 프로세스가 종료되거나 Waiting 상태로 전환되지 않은 상태에서 스케줄러가 실행되는 경우에, 스케줄러는 Ready 상태의 프로세스들과 현재의 Running 상태의 프로세스를 포함한 집합에서 하나를 선택한다.
- 이 과정에서 현재 Running 상태의 프로세스가 아닌 다른 프로세스가 선택되면, 현재 Running 상태의 프로세스는 밀려나서 Ready 상태로 전환된다.

## 프로세스 상태 천이도
![image](https://github.com/user-attachments/assets/1804f24e-122d-48cf-b853-022ea6306bde)
![image](https://github.com/user-attachments/assets/bb7b526a-557b-466f-8ed2-261509d27127)
**(프로세스 상태)**
- 프로세스는 항상 다음 중 하나의 상태에 있게 된다.
- 스케줄링은 Ready 상태의 프로세스들 중에서 하나를 선택하여 Running 상태로 결정하는 작업이 된다.
  - **Running**: CPU에 의해 현재 실행되고 있는 상태
  - **Ready**: 실행 가능 상태로 스케줄러는 이 상태의 프로세스들 중 하나를 선택한다. 여기서 선택된 프로세스는 running 상태로 전환된다.
  - **Waiting**: 특정 조건이 만족될 때까지는 실행될 수가 없는 상태로 스케줄러는 Waiting 상태의 프로세스들은 선택 대상에서 제외한다.
  - **Suspended**: 강제로 실행이 무기한 중지된 상태로서 스케줄러의 선택 대상에서 제외된다.(suspend 시스템 콜 함수에 의해 Suspended 상태로 전환될 수 있다.)
    - Suspended 상태의 프로세스들은 이후에 activate 시스템 콜 함수에 의해 원래의 상태로 되돌아간다.
    - 원래 Running 상태에 있던 프로세스는 Ready 상태로 전환된다. 



